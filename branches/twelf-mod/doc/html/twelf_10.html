<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on April, 3 2009 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Twelf User's Guide: 10. Coverage</title>

<meta name="description" content="Twelf User's Guide: 10. Coverage">
<meta name="keywords" content="Twelf User's Guide: 10. Coverage">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Coverage"></a>
<a name="SEC59"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="twelf_9.html#SEC58" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC60" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="twelf_9.html#SEC52" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="twelf.html#Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="twelf_11.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="twelf.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="twelf_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="twelf_18.html#SEC100" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="twelf_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 10. Coverage </h1>


<p>Coverage checking can verify that no cases in the definition of a type
family have omitted.  In combination with mode and termination checking,
it is a powerful tool for analysing signatures.  Its primary use in
Twelf is for verifying totality of higher-level judgments, which can
thereby be seen to represent proofs of meta-theorems.
</p>
<p>There are several features of LF and its use as a logical framework which
make coverage checking a complex problem.
</p>
<p>The first is that higher-order representations often require us to
consider classes of contexts.  For example, in the program for type
inference (see section <a href="twelf_6.html#SEC35">Sample Program</a>) we introduce parameters <code>x:exp</code>
together with a typing assumption <code>u:of x T</code> for some <code>T</code>.
This means the type <code>exp</code> of expressions is dynamically extended
with new parameters, and coverage must take these into account.
</p>
<p>The second are indexed types.  While it easy to see if all cases for a
simple data type such as the natural numbers (either zero or successor)
are covered, it is more difficult to verify whether all cases for
indexed types, such as possible deductions of <em>A</em> implies <em>A</em>,
are covered.
</p>
<p>The third is the higher-order nature of encodings.  We may have to
verify that all functions of a given type have been covered, not just
values of atomic type.  The fact that functions in LF must be parametric
makes this possible, but it can be subtle.
</p>
<p>Coverage addresses all three of these problems in different ways.  The
programmer can specify the kinds of parameters and hypotheses considered
valid for an encoding.  <em>World checking</em> verifies that this
specification is respected.  The programmer can also specify which
arguments of a given type family should cover all possibilities
exhaustively.  <em>Coverage checking</em> verifies that this is indeed the
case, or produces a list of missing cases.  Coverage checking is always
relative to a world declaration.  Finally, <em>totality checking</em>
verifies both coverage and termination, thereby ensuring that any
mode-correct invocation of the type family considered as a logic program
will succeed.  Hence, a total type family represents a total, possibly
non-deterministic, function and can thus be often seen to realize a
meta-theoretic proof.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC60">10.1 Regular Worlds</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Characterizing parameters and hypotheses
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC61">10.2 Input Coverage</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">              Checking if all cases have been covered
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC62">10.3 Totality</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    Verifying if a family is total in its input
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC63">10.4 Subordination</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               How constants depend on each other
</td></tr>
</table>

<hr size="6">
<a name="Regular-Worlds"></a>
<a name="SEC60"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC59" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC61" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC59" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC59" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="twelf_11.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="twelf.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="twelf_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="twelf_18.html#SEC100" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="twelf_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 10.1 Regular Worlds </h2>


<p>The adequacy of an encoding using higher-order abstract syntax usually
relies on a characterization of the possible parameters and hypotheses
that may be introduced.  They often occur in blocks of assumptions that
have to be made together in order for a representation to be correct.
We refer to the total collection of assumptions as <em>regular worlds</em>
consisting of <em>blocks</em>.
</p>
<p>In Twelf, we first declare names for such blocks with <code>%block</code>,
then we check if a given type family respects this block structure
with <code>%worlds</code>.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">decs ::=                         % Empty parameter declaration
       | {id:term} decs          % <em>x:A</em> for parameter <em>x</em>
       | {id} decs               % <em>x:A</em> with type <em>A</em> omitted

bdecl ::= some decs block decs   % Blocks with indeterminate variables
        | block decs             % Closed blocks

worlds ::=                       % Empty world
         | id                    % Block label <em>b</em>
         | id | worlds           % Block label <em>b</em> and alternatives

wdecl ::= (worlds) callpats.     % Worlds declaration

decl ::= &hellip;
       | %block id : bdecl.      % Block declaration with label <em>b</em>
       | %worlds wdecl.          % Regular world declaration
</pre></td></tr></table>
<p>The syntactic category of call patterns (<em>callpats</em>) was in introduced
in <a href="twelf_9.html#SEC53">Termination Declaration</a>.
</p>
<p>Consider the typing judgment from <a href="twelf_6.html#SEC35">Sample Program</a>
which can also be found in file <tt>`examples/guide/lam.elf'</tt>.
We show only the last three declarations here.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">of : exp -&gt; tp -&gt; type.

tp_lam : of (lam E) (arrow T1 T2)
          &lt;- ({x:exp} of x T1 -&gt; of (E x) T2).

tp_app : of (app E1 E2) T1
          &lt;- of E1 (arrow T2 T1)
          &lt;- of E2 T2.
</pre></td></tr></table>
<p>Note that every time the clause <code>tp_lam</code> is invoked, it introduces
a new parameter <code>x:exp</code> and also a new assumption <code>of x T</code>
for some <code>T</code>.  In order for type inference to work correctly, it
is important that those two hypotheses always occur together.  So, in
general, the context consisting of all hypotheses should have the form
<code>x1:exp, u1:of x1 T1, ..., xn:exp, un:of xn Tn</code>.  We call this
a <em>regular context</em>.  It consists of <em>blocks</em> of the
form <code>x:exp, u:of x T</code> for some <code>T</code>.
</p>
<p>We declare this block, labeled <code>tp_var</code>, and then verify
that any hypotheses introduced by the type family <code>of</code>
will have this form.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%block tp_var : some {T:tp} block {x:exp} {u:of x T}.
%worlds (tp_var) (of E T).
</pre></td></tr></table>
<p>Our encoding of natural deduction (see see section <a href="twelf_3.html#SEC13">Sample Signature</a> and file
<tt>`examples/guide/nd.elf'</tt>) shows that regular worlds also arise when
a signature does not have an immediate operational interpretation.
In this case, we may generate either a new parameter <code>x:i</code>
(in <code>foralli</code> and <code>existse</code>) or a new assumption
<code>u:nd A</code> for some proposition <code>A</code> (in <code>impi</code>,
<code>ore</code>, and <code>existse</code>).  This can be verified with
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%block nd_hyp : some {A:o} block {u:nd A}.
%block nd_parm : block {x:i}.
%worlds (nd_hyp | nd_parm) (nd A).
</pre></td></tr></table>
<p>There are several subtleties in world checking.
</p>
<dl compact="compact">
<dt> Weakening.</dt>
<dd><p> The blocks listed in the worlds declaration need not actually be used
anywhere in the type family that is checked.  That is, we can always
weaken blocks.
</p>
</dd>
<dt> Duplication.</dt>
<dd><p> Arbitrarily many blocks may be introduced before each call to a type
family.  That is, we can always duplicate blocks.
</p>
</dd>
<dt> No exchange.</dt>
<dd><p> No exchange of declarations, either within a block or between different
blocks is allowed.  This simplifies world checking and improves error
messages, but occasionally suggest some minor rewriting, such as using
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">... &lt;- ({x:exp} of x T -&gt; {y:exp} of y S -&gt; ...)
</pre></td></tr></table>
<p>instead of
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">... &lt;- ({x:exp} {y:exp} of x T -&gt; of y S -&gt; ...).
</pre></td></tr></table>
</dd>
<dt> Strengthening.</dt>
<dd><p> The worlds declared for a type family <em>a</em> cannot anticipate all
possible future uses of <em>a</em>.  It is therefore legal to use <em>a</em>
in an extended regular world, as long as it is clear that the additional
hypotheses cannot interfere with <em>a</em>.  This condition of non-interference
is verified via subordination.
</p></dd>
</dl>

<p>As a special case of regular world declaration, the form
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%worlds () callpats.
</pre></td></tr></table>

<p>declares that the type families in <em>callpats</em> do not introduce any
new parameters or hypotheses.
</p>
<hr size="6">
<a name="Input-Coverage"></a>
<a name="SEC61"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC60" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC62" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC59" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC59" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="twelf_11.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="twelf.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="twelf_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="twelf_18.html#SEC100" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="twelf_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 10.2 Input Coverage </h2>


<p>Once a set of regular worlds has been declared for a type family, Twelf
can determine if all the possible cases for a given collection of input
arguments are covered.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">decl ::= &hellip;
       | %covers mdecl.    %coverage declaration
</pre></td></tr></table>
<p>This form reuses the mode declaration <em>mdecl</em> introduced in
<a href="twelf_8.html#SEC48">Modes</a> which comes in a short form (see section <a href="twelf_8.html#SEC49">Short Mode Declaration</a>)
and long form (see section <a href="twelf_8.html#SEC50">Full Mode Declaration</a>).  The coverage checker
selects the arguments declared as input (+) and verifies that the given
family provides a clause for any combination of ground input arguments.
The term <em>input coverage</em> emphasizes that we only verify the status
of input arguments to a family, but not indefinite or output arguments.
</p>
<p>For example, in order to check that there is a typing rule for every
expression in the type inference code for Mini-ML (see section <a href="twelf_6.html#SEC35">Sample Program</a>), we first declare the regular world and then check input
coverage.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%block tp_var : some {T:tp} block {x:exp} {u:of x T}.
%worlds (tp_var) (of E T).
%covers of +E *T.
</pre></td></tr></table>
<p>Coverage checking takes dependent types and subordination into
account, but it is a decidable, syntactic test rather than a
semantic criterion.  This means that it can list the missing
cases when it fails.  For example, if we comment out the typing
rule for application, we obtain the following error message:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">Coverage error --- missing cases:
{E1:exp} {E2:exp} {T1:tp} |- of (app E1 E2) T1.
</pre></td></tr></table>
<p>The format of the missing cases is <code>G |- A</code>, where <code>A</code> is a
form of goal for which does not unify with the head of any clause and
<code>G</code> is a context declaring the types for the free (existential)
variables in <code>A</code>.
</p>
<p>A more subtle error occurs, if we forget the typing assumption for
a new variable.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">...
tp_lam : of (lam E) (arrow T1 T2)
          &lt;- ({x:exp} of (E x) T2).

%block tp_var : some {T:tp} block {x:exp}. % {u:of x T}.
%worlds (tp_var) (of E T).
%covers of +E *T.
</pre></td></tr></table>
<p>Clearly, coverage has to fail since there is no typing assumption for
bound variables.  In this case we get the error message
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">Coverage error --- missing cases:
{T1:tp} {#tp_var:{x:exp}} {T2:tp} |- of #tp_var_x T2.
</pre></td></tr></table>
<p>Here we see the notation for parameters in context blocks.  The goal
<code>of #tp_var_x T2</code> refers to a parameter called <code>x</code> in the
context block <code>tp_var</code>.  The hypotheses available with this block
are listed in the declaration <code>{#tp_var:{x:exp}}</code>.  This block
contains no typing assumption for <code>x</code> and coverage is violated.
Note that this notation can never be an input to Twelf; it is only
used for error messages.
</p>
<p>One of the most difficult errors to analyse occurs when coverage is
violated due to argument transposition and dependencies.  In that
situation the error is often reflected in implicit arguments which may
not be easy to discern.  An example of this form is given below in
the next section.
</p>
<hr size="6">
<a name="Totality"></a>
<a name="SEC62"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC61" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC63" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC59" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC59" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="twelf_11.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="twelf.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="twelf_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="twelf_18.html#SEC100" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="twelf_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 10.3 Totality </h2>


<p>The most advanced application of coverage checking is verifying the
totality of a given type family.  This is usually used to ascertain that
a given higher-level type family implements a meta-theoretic proof.
Checking that a type family is total requires, in this order, mode
checking, world checking, termination checking, and coverage checking.
Mode and world declarations have to be made separately, while termination
and coverage checking are folded into a single declaration.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">decl ::= &hellip;
       | %total tdecl.    %totality declaration
</pre></td></tr></table>
<p>Here <em>tdecl</em> is a termination declaration introduced in
<a href="twelf_9.html#SEC53">Termination Declaration</a>.  A totality declaration is processed
in the following steps.
</p>
<dl compact="compact">
<dt> Modes.</dt>
<dd><p> Twelf verifies that the type families in <em>tdecl</em> all have
declared modes.  Indefinite modes (<code>*</code>) are not allowed.
</p>
</dd>
<dt> Worlds.</dt>
<dd><p> Twelf verifies that the type families in <em>tdecl</em> all have
declared worlds.
</p>
</dd>
<dt> Termination.</dt>
<dd><p> Twelf executes the termination checker using the <em>tdecl</em>.  If it
passes this test, it means that any well-moded query for the given
families terminates, either with success or failure.
</p>
</dd>
<dt> Input Coverage.</dt>
<dd><p> Twelf then executes coverage checking according on the input arguments
to the families based on the prior mode declarations.  If the family
passes this test, it means that a clause applies to any well-moded query
with free existential variables as output arguments.
</p>
</dd>
<dt> Output Coverage.</dt>
<dd><p> Twelf finally checks all subgoals in the given program in a final pass
If the output arguments to the subgoal cover all the possible values
that may be returned in these position, we say that <em>output
coverage</em> succeeds.  In the simplest and most frequent case the output
argument is an existential variable of most general type, which automatically
covers all possibilities for closed terms of the given type.
</p></dd>
</dl>

<p>As an example, we use type preservation, a continuation of the
sample programs for type inference and evaluation in Mini-ML
(see see section <a href="twelf_6.html#SEC35">Sample Program</a> and file <tt>`examples/guide/lam.elf'</tt>).
This can be proven automatically (see see section <a href="twelf_11.html#SEC66">Sample Theorems</a>), but
we can also give the proof by hand and have Twelf verify it via
totality checking.
</p>
<p>First, the correct program and verification.  The type preservation
theorem states that for any closed evaluation <code>D:eval E V</code> and
typing derivation <code>P:of E T</code> there exists a typing derivation
<code>Q:of V T</code>.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">tps : eval E V -&gt; of E T -&gt; of V T -&gt; type.

tps_lam : tps (ev_lam) (tp_lam P) (tp_lam P).
tps_app : tps (ev_app D3 D2 D1) (tp_app P2 P1) Q
           &lt;- tps D1 P1 (tp_lam Q1')
           &lt;- tps D2 P2 Q2
           &lt;- tps D3 (Q1' V2 Q2) Q.

%mode tps +D +P -Q.
%worlds () (tps D P _).
%total D (tps D P _).
</pre></td></tr></table>
<p>The mode declaration specifies that the evaluation and typing derivation
for <code>E</code> are input, while the typing derivation for <code>V</code> is
output.  The worlds declaration expresses that expressions and types
must be closed, that is, not depend on any parameters.  The final
totality declaration claims that the logic programming execution of
<code>tps D P Q</code> for ground <code>D</code> and <code>P</code> and free existential
variable <code>Q</code> terminates because <code>tps</code> is inductively defined
based on the structure of <code>D</code>.  Note that this implies that the
meta-theorem of type preservation holds, because the type family
<code>cps</code> realizes the proof: it can always compute a typing derivation
<code>Q:of V T</code> when given arbitrary evaluation <code>D:eval E V</code> and
typing derivation <code>P:of E T</code>.
</p>
<p>The signature above passes all three tests.  The main subtlety in this
example lies in the output coverage of the first subgoal
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">  &lt;- tps D1 P1 (tp_lam Q1')
</pre></td></tr></table>
<p>How does Twelf know that any typing derivation <code>Q1</code> returned by a
call <code>tps D1 P1 Q1</code> must in fact have the form <code>tp_lam Q1'</code>
for some <code>Q1'</code>?  Here, this follows by the structure of the
indexed types: <code>Q1 : of (lam [x] E1' x) (arrow T2 T1)</code> for some
<code>E1'</code>, <code>T1</code>, and <code>T2</code>.  Hence there remains only one
applicable top-level constructor for <code>Q1</code>, namely <code>tp_lam</code>,
which corresponds to the typing rule lambda-abstraction.  In informal
proofs, we refer to this as <em>inversion</em> or <em>genericity</em>.
</p>
<p>For the sake of illustration, we introduce two bugs into our proof
and analyse the error message.  In the first, we reverse the arguments
<code>D2</code> and <code>D3</code> in rule <code>tps_app</code>.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">tps_app : tps (ev_app D2 D3 D1) (tp_app P2 P1) Q
           &lt;- tps D1 P1 (tp_lam Q1')
           &lt;- tps D2 P2 Q2
           &lt;- tps D3 (Q1' V2 Q2) Q.
</pre></td></tr></table>
<p>The resulting clause still passes all test up to input coverage, which
fails with the message
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">Coverage error --- missing cases:
{E1:exp} {E2:exp} {E3:exp} {T1:tp} {E4:exp -&gt; exp} {E5:exp}
   {D1:eval (E4 E5) E3} {D2:eval E2 E5}
   {D3:eval E1 (lam ([e:exp] E4 e))} {T2:tp} {P1:of E2 T2}
   {P2:of E1 (arrow T2 T1)} {P3:of E3 T1}
   |- tps (ev_app D1 D2 D3) (tp_app P1 P2) P3.
</pre></td></tr></table>
<p>This clearly identifies the missing case, but it does not help much in
identifying which the rule <code>tps_app</code> fails to cover the given case.
If look back at the declaration for <code>tps_app</code> after reconstruction
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">tps_app :
   {E1:exp -&gt; exp} {V2:exp} {T1:tp} {D3:eval (E1 V2) V2} {T2:tp}
      {Q1':{e:exp} of e T2 -&gt; of (E1 e) T1} {Q2:of V2 T2} {Q:of V2 T1}
      {D2:eval (E1 V2) V2} {P2:of (E1 V2) T2} {E2:exp}
      {D1:eval E2 (lam ([e:exp] E1 e))} {P1:of E2 (arrow T2 T1)}
      tps D3 (Q1' V2 Q2) Q -&gt; tps D2 P2 Q2 -&gt; tps D1 P1 (tp_lam Q1')
         -&gt; tps (ev_app D2 D3 D1) (tp_app P2 P1) Q.
</pre></td></tr></table>

<p>we see that <code>{D3:eval (E1 V2) V2}</code> which is clearly non-sensical
and points to an argument ordering problem (<code>V</code> and <code>V2</code>
have been identified).
</p>
<p>As the second example of an intentional problem, we use an apparently
correct implementation of a <code>copy</code> family implements the identity
relation on expressions recursively (see file
<tt>`example/guide/lam.elf'</tt>).
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">cp : exp -&gt; exp -&gt; type.
cp_app : cp (app E1 E2) (app F1 F2)
          &lt;- cp E1 F1
          &lt;- cp E2 F2.

cp_lam : cp (lam [x] E x) (lam [x] F x)
          &lt;- ({x:exp} {y:exp} cp x y -&gt; cp (E x) (F y)).

%mode cp +E -F.
%block cp_var : block {x:exp} {y:exp} {u:cp x y}.
%worlds (cp_var) (cp E _).
%total E (cp E _).
</pre></td></tr></table>
<p>This fails with the message
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">Coverage error --- missing cases:
{#cp_var:{x:exp} {y:exp} {u:cp x y}} {E1:exp} |- cp #cp_var_y E1.
</pre></td></tr></table>

<p>because the parameter <code>y:exp</code> is not accompanied by an assumption
on how to copy <code>y</code>.  Twelf does not perform the global analysis
that would be necessary to show that <code>y</code> actually can never occur
as a first argument to <code>cp</code>.  If we introduce such an assumption,
for example, <code>cp y y</code>,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">cp : exp -&gt; exp -&gt; type.
cp_app : cp (app E1 E2) (app F1 F2)
          &lt;- cp E1 F1
          &lt;- cp E2 F2.

cp_lam : cp (lam [x] E x) (lam [x] F x)
          &lt;- ({x:exp} {y:exp} cp x y -&gt; cp y y -&gt; cp (E x) (F y)).

%mode cp +E -F.
%block cp_var : block {x:exp} {y:exp} {u:cp x y} {w:cp y y}.
%worlds (cp_var) (cp E _).
%total E (cp E _).
</pre></td></tr></table>

<p>then totality checking still fails.  The error message
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">Totality: Output of subgoal not covered
Output coverage error --- missing cases:
{E1:exp -&gt; exp} {E2:exp -&gt; exp -&gt; exp}
   |- {x:exp} {y:exp} cp x y -&gt; cp y y -&gt; cp (E1 x) (E2 x y).
</pre></td></tr></table>

<p>shows that Twelf expected the output argument of the recursive call to
possibly depend on both <code>x</code> and <code>y</code>, while the corresponding
pattern <code>F y</code> allowed dependency only on <code>y</code>.  Again, Twelf
does not perform the global analysis necessary to show that <code>x</code> can
never appear in the output argument of <code>cp</code>.
</p>
<p>A correct and checkable implementation of <code>cp</code> introduces only one new
parameter, thereby avoiding the problems above.
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">cp : exp -&gt; exp -&gt; type.
cp_app : cp (app E1 E2) (app F1 F2)
          &lt;- cp E1 F1
          &lt;- cp E2 F2.

cp_lam : cp (lam [x] E x) (lam [x] F x)
          &lt;- ({x:exp} cp x x -&gt; cp (E x) (F x)).

%mode cp +E -F.
%block cp_var : block {x:exp} {u:cp x x}.
%worlds (cp_var) (cp E _).
%total E (cp E _).
</pre></td></tr></table>
<hr size="6">
<a name="Subordination"></a>
<a name="SEC63"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC62" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="twelf_11.html#SEC64" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC59" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC59" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="twelf_11.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="twelf.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="twelf_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="twelf_18.html#SEC100" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="twelf_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 10.4 Subordination </h2>


<p>An important component for termination checking and coverage
checking is <em>subordination</em> <cite>Virga 99, Ph.D. Thesis</cite>.
We say that type family <var>b</var> subordinates type family
<var>a</var> (written <code><var>b</var> |&gt; <var>a</var></code>) if a term of typ
<code><var>b</var> &hellip;</code>
might occur as a subterm of a term of type <code><var>a</var> &hellip;</code>.
From the point of view of the application in Twelf, it is
the contrapositive that is important: if <var>b</var> does not
subordinate <var>a</var>, then no subterm of type <code><var>a</var> &hellip;</code>
can occur in a subterm of type <code><var>b</var> &hellip;</code>.  The notion
of occurrence here refers to terms in canonical form.
</p>
<p>As Twelf performs type reconstruction, it incrementally
keeps track of the subordination relation.  It can be viewed
at any time with the
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">Twelf.Print.subord ();
</pre></td></tr></table>
<p>command.  For each type family it shows the families that it
subordinates.
</p>
<p>Subordination information is used in <a href="twelf_9.html#SEC52">Termination</a> and
<a href="#SEC59">Coverage</a>.
</p>
<p>Sometimes it is necessary to ensure that a given type
family is not extended with additional constructors that might
invalidate meta-theorems or add new (unwanted) axioms to a theory
represented in LF.  In order to prohibit further extensions to
some type families, issue
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%freeze <var>a1</var> &hellip; <var>an</var>.
</pre></td></tr></table>
<p>to prevent further declarations of type <var>a1</var> through <var>an</var>
or any other type family subordinated by one of the <var>a</var>'s.
</p>
<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC59" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="twelf_11.html#SEC64" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="twelf.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="twelf_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="twelf_18.html#SEC100" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="twelf_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Florian Rabe</em> on <em>April, 3 2009</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
