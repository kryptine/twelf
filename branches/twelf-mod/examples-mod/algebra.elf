% Algebraic hierarchy


%sig FOL = {
  i      : type.
  o      : type.
  forall : (i -> o) -> o.
  not    : o -> o.
  and    : o -> o -> o.         %infix none 3 and.
  =>     : o -> o -> o.         %infix none 2 =>.
  <=>    : o -> o -> o
         = [x][y]((x => y) and (y => x)).
                                %infix none 1 <=>.
  ==     : i -> i -> o.         %infix none 4 ==.
  !=     : i -> i -> o
         = [x][y] not (x == y). %infix none 4 !=.
  ded : o -> type.              %prefix 0 ded.
}.


%sig Magma = {
  %include FOL.
  * : FOL.i -> FOL.i -> FOL.i.    %infix none 10 *.
}.

%sig MagmaCommut = {
  %include FOL.
  %struct mag : Magma. 
  commut : FOL.ded FOL.forall [x] FOL.forall [y] (x mag.* y FOL.== y mag.* x).
}.

%sig Semigroup = {
  %include FOL.
  %struct mag : Magma.
  assoc : FOL.ded FOL.forall [x] FOL.forall [y] FOL.forall [z] ((x mag.* y) mag.* z FOL.== x mag.* (y mag.* z)).
}.

%sig SemigroupCommut = {
  %include FOL.
  %struct sg : Semigroup.
  %struct mc : MagmaCommut = {%struct mag := sg.mag.}.
}.

%sig MagmaDistrib = {
  %include FOL.
  %struct mag1 : Magma.
  %struct mag2 : Magma.
  + = [x] [y] x mag1.* y.
  * = [x] [y] x mag2.* y.
  %infix none 5 +.
  %infix none 10 *.    
  dist : FOL.ded FOL.forall [x] (FOL.forall [y] (FOL.forall [z] ((x + y) * z FOL.== x * z + y * z))).
}.

%sig MagmaIdempotent = {
  %include FOL.
  %struct mag : Magma. 
  idem : FOL.ded FOL.forall [x] (x mag.* x FOL.== x). 
}.

%sig MagmaIdentity = {
  %include FOL.
  %struct mag : Magma. 
  e : FOL.i.
  idenRight : FOL.ded FOL.forall [x] (x mag.* e FOL.== x).
  idenLeft : FOL.ded FOL.forall [x] (e mag.* x FOL.== x).
}.

%sig Monoid = {
  %include FOL.
  %struct sg : Semigroup.
  %struct mid : MagmaIdentity = {%struct mag := sg.mag.}. 
  e = mid.e.
}.

%sig MonoidCommut = {
  %include FOL.
  %struct mon : Monoid.
  %struct mc : MagmaCommut = {%struct mag := mon.sg.mag.}.
}.

%sig MagmaInverse = {
  %include FOL.
  %struct mid : MagmaIdentity.
  inv : FOL.i -> FOL.i.
  invRight : FOL.ded FOL.forall [x] (x mid.mag.* (inv x)  FOL.==  mid.e).
  invLeft : FOL.ded FOL.forall [x] ((inv x) mid.mag.* x  FOL.==  mid.e). 
}. 

%sig Group = {
  %include FOL.
  %struct mon : Monoid.
  %struct minv : MagmaInverse = {%struct mid := mon.mid.}.
  inv = minv.inv.
}.

%sig GroupAbelian = {
  %include FOL.
  %struct g : Group.
  %struct mc : MagmaCommut = {%struct mag := g.mon.sg.mag.}.
  + = [x][y] x g.mon.sg.mag.* y.    %infix none 5 +.  
  0 = g.mon.mid.e.
  - = g.inv.  
}.

%sig Ring = {
  %include FOL.
  %struct ga : GroupAbelian.
  %struct sg : Semigroup.
  %struct md : MagmaDistrib = {%struct mag1 := ga.g.mon.sg.mag. %struct mag2 := sg.mag.}.
}.

%sig RingCommut = {
  %include FOL.
  %struct r : Ring.
  %struct mc : MagmaCommut = {%struct mag := r.sg.mag.}.
}.

%sig RingUnit = {
  %include FOL.
  %struct r : Ring.
  %struct mon : Monoid = {%struct sg := r.sg.}.
  1 = mon.e.
}.

%sig RingUnitCommut = {
  %include FOL.
  %struct ru : RingUnit.
  %struct mc : MagmaCommut = {%struct mag := ru.mon.sg.mag.}.
}.

%sig IntegralDomain = {
  %include FOL.
  %struct ru : RingUnit.
  noZeroDiv : FOL.ded
    FOL.forall [x] FOL.forall [y] (
          x  FOL.!=  ru.r.ga.0
        FOL.and
          y  FOL.!=  ru.r.ga.0
      FOL.=>
        x ru.r.sg.mag.* y  FOL.!=  ru.r.ga.0 ).
}.  

%sig RingDivision = {
  %include FOL.
  %struct ru : RingUnit.
  inv : FOL.i -> FOL.i.
  invLeft : FOL.ded
    FOL.forall [x] (
        x FOL.!= ru.r.ga.0
      FOL.=>
        x ru.mon.sg.mag.* (inv x)  FOL.==  ru.1
    ). 
  invRight : FOL.ded
    FOL.forall [x] (
        x FOL.!= ru.r.ga.0
      FOL.=>
        (inv x) ru.mon.sg.mag.* x  FOL.==  ru.1
    ).
}.

%sig Field = {
  %include FOL.
  %struct rd : RingDivision.
  %struct mc : MagmaCommut = {%struct mag := rd.ru.mon.sg.mag.}.
}.