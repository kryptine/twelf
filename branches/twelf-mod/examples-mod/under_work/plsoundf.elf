%sig Base = {
  o     : type.
  ded   : o -> type. 
}.

%sig Truth = {
  %struct base     : Base   %open o.
  true  : o.
}.

%sig Falsity = {
  %struct base     : Base   %open o.
  false : o.
}.

%sig NEG = {
  %struct base     : Base   %open o.
  not   : o -> o.
}.

%sig IMP = {
  %struct base     : Base   %open o.
  imp   : o -> o -> o.        %infix none 15 imp.
}.

%sig CONJ = {
  %struct base     : Base   %open o.
  and   : o -> o -> o.        %infix none 10 and.
}.

%sig DISJ = {
  %struct base     : Base   %open o.
  or   : o -> o -> o.         %infix none 10 or.
}.

%sig PL = {
  %struct base     : Base.
  %struct truth    : Truth   = {%struct base := base.}.
  %struct falsity  : Falsity = {%struct base := base.}.
  %struct neg      : NEG     = {%struct base := base.}.
  %struct impl     : IMP     = {%struct base := base.}.
  %struct conj     : CONJ    = {%struct base := base.}.
  %struct disj     : DISJ    = {%struct base := base.}.
}. 

%sig BasePF = {
 %struct base      : Base.
}.

%sig TruthPF = {
  %struct basepf   : BasePF %open base.ded.
  %struct truth    : Truth    = {%struct base := basepf.base.}  %open true.
  trueI  : ded true.
}.

%sig FalsityPF = {
  %struct basepf   : BasePF %open base.ded.
  %struct falsity  : Falsity  = {%struct base := basepf.base.}  %open false.
  falseE : ded false -> {A} ded A.
}.

%sig NEGPF = {
  %struct basepf   : BasePF %open base.ded.
  %struct neg      : NEG      = {%struct base := basepf.base.}  %open not.
  notI   : (ded A -> {B} ded B) -> ded (not A).
  notE   : ded A -> ded (not A) -> {B} ded B.
}.

%sig IMPPF = {
  %struct basepf   : BasePF %open base.ded.
  %struct impl     : IMP      = {%struct base := basepf.base.}  %open imp.
  impI   : (ded A -> ded B) -> ded (A imp B).
  impE   : ded (A imp B) -> ded A -> ded B.
}.

%sig CONJPF = {
  %struct basepf   : BasePF %open base.ded.
  %struct conj     : CONJ      = {%struct base := basepf.base.}  %open and.
  andI   : ded A -> ded B -> ded (A and B).
  andEl  : ded (A and B) -> ded A.
  andEr  : ded (A and B) -> ded B.
}.

%sig DISJPF = {
  %struct basepf   : BasePF %open base.ded.
  %struct disj     : DISJ      = {%struct base := basepf.base.}  %open or.
  orIl    : ded A -> ded (A or B).
  orIr    : ded B -> ded (A or B).
  orE     : ded (A or B) -> (ded A -> ded C) -> (ded B -> ded C) -> ded C.
}.

%sig PLPF = {
  %struct basepf    : BasePF.
  %struct truthpf   : TruthPF = {%struct basepf := basepf.}.
  %struct falsitypf : FalsityPF = {%struct basepf := basepf.}.
  %struct negpf     : NEGPF = {%struct basepf := basepf.}.
  %struct imppf     : IMPPF = {%struct basepf := basepf.}.
  %struct conjpf    : CONJPF = {%struct basepf := basepf.}.
  %struct dispf     : DISJPF = {%struct basepf := basepf.}.
}.

%{
%sig PL_rest = {  
  
  tnd    : ded ((not (not A)) imp A).
}.
}%

%sig BaseMOD = {
  %include MLTT %open tm tp - == ==' + subsType @.
  o'    : tp.
  ded'  : o' -> tp.
  %struct base : Base = {o := tm o'. ded := [a] tm (ded' a).}.
}.

%sig TruthMOD = {
 %struct basemod : BaseMOD.
}.

%sig FalsityMOD = {}.
%sig NEGMOD = {}.
%sig IMPMOD = {}.
%sig CONJMOD = {}.
%sig DISJMOD = {}.


%sig PLMOD = {
  
  
  1 : o.
  0 : o.
  desig0 : - (ded' 0).
  desig1 : ded 1.
  boole : {A} (A ==' 1 + A ==' 0).
  
  trueTrue : true == 1.
  falseFalse : false == 0.
  impTrue : A ==' 0 + B ==' 1 -> (A imp B) == 1.
  impFalse: A == 1 -> B == 0 -> (A imp B) == 0.
  notTrue : A == 0 -> (not A) == 1.
  notFalse : A == 1 -> (not A) == 0.
  
  ded-true : ded A -> A == 1
           = [p] (MLTT..D.case (boole A)
                     ([q : A == 1] q)
                     ([q : A == 0] (MLTT..!! (desig0 @ (MLTT..I.eq (subsType q ded') p))))
                 ).
  true-ded : A == 1 -> ded A
           = [p] (MLTT..I.eq (MLTT..TT.sym (subsType p ded')) desig1).
  cons  : - (0 ==' 1)
        = MLTT..lam [p : 0 == 1] (desig0 @ (MLTT..I.eq (MLTT..TT.sym (subsType p ded')) desig1)).
  contra : A == 0 -> A == 1 -> MLTT..void
         = [p][q] (cons @ (MLTT..I.trans (MLTT..I.sym p) q)).
}.

%view PLsound : PLPF -> PLMOD = {
  trueI := true-ded trueTrue.
  falseE := [p : ded false][A] (MLTT..!! (contra falseFalse (ded-true p))).
  impI := [A][B][p: ded A -> ded B] (
             true-ded (impTrue 
               (MLTT..case (boole A)
                  ([q : A == 1] MLTT..inj2 (ded-true (p (true-ded q))))
                  ([q : A == 0] MLTT..inj1 q)
               )
             )
          ).
  impE := [A][B][p : ded (A imp B)][q : ded A] (
             true-ded (
                MLTT..D.case (boole B)
                   ([r : B == 1] r)
                   ([r : B == 0] MLTT..!! (contra (impFalse (ded-true q) r) (ded-true p)))
             )
          ).
  notI := [A][p : ded A -> {B} ded B] (
             MLTT..D.case (boole A)
                ([q : A == 1] p (true-ded q) (not A))
                ([q : A == 0] true-ded (notTrue q))
          ).
  notE := [A] ([p : ded A] [q : ded (not A)] [B] MLTT..!! (contra (notFalse (ded-true p)) (ded-true q))).
  tnd := [A] true-ded (
               impTrue (
                 MLTT..case (boole A)
                    ([p : A == 1] MLTT..inj2 p)
                    ([p : A == 0] MLTT..inj1 (notFalse (notTrue p)))
               )
             ).
}.

%}