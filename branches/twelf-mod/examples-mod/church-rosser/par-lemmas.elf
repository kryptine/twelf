%%% Basic lemmas concerning parallel reductions
%%% Author: Frank Pfenning
% Every lc.term reduces to itself (in parallel)

%sig BASIC = {
    %struct lc: LC = {}.
    %struct par: PAR = {%struct lc := lc.}. 

%abbrev test : lc.term -> par.lc.term = [x]x.

identity : {M:lc.term} par.=> M M  ->  type.

%mode identity +M -R.
    %sig lid = {x:lc.term.
             eqx: x par.=> x.
              u:identity x eqx.}.
    
    id_lam : identity (lc.lam M1) (par.lm R1)
       <- ({x:lc.term} {eqx: x par.=> x}
	     identity x eqx -> identity (M1 x) (R1 x eqx)).

     id_app : identity (lc.app M1 M2) (par.ap R1 R2)
       <- identity M1 R1
       <- identity M2 R2.


    %total (lid) M (identity M _).
%worlds (lid) (identity M R).
%covers identity +M -R.
%lc.terminates M (identity M _).
%total M (identity M _).
}% 

%  Parallel multi-step reduction is transitive.

append : M par.=>* M'  ->  M' par.=>* M''  ->  M par.=>* M''  -> type.
%mode append +R* +S* -S*'.

append_id   : append par.id S* S*.
append_step : append (R1 par.; R2*) S* (R1 par.; S2*')
           <- append R2* S* S2*'.

%{
%worlds () (append R* S* S*').
%covers append +R* +S* -S*'.
%lc.terminates R* (append R* S* _).
%total R* (append R* S* _).
}%
}.