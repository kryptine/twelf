
%sig P = {
  o: type.
  =>: o -> o -> o.    %infix left 10 =>.
  ~ : o -> o.
  n =  [p] (~ (~ p)).
}.

%sig IL = {
  %struct P : P.
  true : P.o -> type.
  =>I : (true A -> true B) -> true (A P.=> B).
  =>E : true (A P.=> B) -> true A -> true B.
  ~I : ({p} true A -> true p) -> true (P.~ A).
  ~E : true (P.~ A) -> true A -> true C.
  ~~I : true A -> true (P.n A) = [D] (~I [p:P.o] [u: true (P.~ A)] (~E u D)).
}.

%sig CL = {
	 %struct P : P.
       	 %struct IL : IL = {%struct P := P.}.
         exm : IL.true (P.~ (P.~ A) P.=> A). 
}.

%view KOLM : CL -> IL = {
   P.o := P.o.
   P.=> := [x][y] ((P.n x) P.=> (P.n y)).
   P.~ := [x] P.~ x.
   IL.true := [x] true (P.n x).
   IL.=>I := [A][B][D] ~~I (=>I D).  %% implicit arguments don't work here yet
   IL.=>E := [A][B][D][E] ~I [p][u] ~E D (~I [q][v] ~E (=>E  v E) u).
   IL.~I := [A][D] ~I [q][u] ~E (D (P.~ A) u) u.
   IL.~E := [A][C][D][E] ~I [p][u] ~E D E .
   exm := [A] ~I [p] [u] ~E u (=>I [u] ~I [p] [v] ~E u (~I [q][w] ~E w v)).
   % leftover logic variables should not be abstracted.  BUG?
}.


%view KOLMINV : IL -> CL = {
   P.o := P.o.			      
   P.=> := [x][y] x P.=> y.
   P.~ := [x] P.~ x.
% true := [x] true x.   %%%%%% BUG
   true := [x] IL.true x.
   =>I := [A][B][D] IL.=>I D.
   =>E := [A][B][D][E] IL.=>E D E.
   ~I := [A][D] IL.~I D.
   ~E := [A][C][D][E] IL.~E D E.
}.


%sig TEST = {
   %struct P : P.
   %struct CL : CL = { %struct P := P.}.
}.

%sig TEST2 = {
   %struct IL : IL.
   %struct t : TEST = { %struct CL := KOLM IL.}.
}
   			
  