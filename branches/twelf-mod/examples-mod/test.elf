%% testing basic syntax
%sig R = {
  a : type.
  c : a.
}.

%% testing basic semantics, note why "test" is well-typed
%sig S = {
  a' : type.
  b' : a'.
  b'2: a'.
  %struct r' : R = {a := a'.}.
  c' : r'.a.
  d' : a' -> type.
  test : d' c'.
}.

%% testing instantiations of structures, try removing the instantantion of a'
%sig T = {
  a'' : type.
  b'' = a'' -> a''.
  %struct r'' : R = {a := a'' -> a''.}.
  %struct s'': S = {a' := b''. %struct r' := r''.}.
}.

%% testing a deep instantiation r''.c := f''', and a structure definition s''' = T..s'' t'''.
%% also try removing the instantiation of a''
%% note that the order of instantiations in a structure is not relevant
%sig U = {
  a''' : type.
  f''' : a''' -> a'''.
  %struct t''' : T = {r''.c := f'''. a'' := a'''.}.
  %struct s''' = T..s'' t'''.
}.

%% testing views
%view V : R -> R = {
  a := a -> a.
  c := [x] c.
}.

%% testing views with structure instantiations; not so easy to type-check by hand anymore
%% note that type reconstruction works
%view W : S -> T = {
  a' := a'' -> a''.
  b' := [x] x.
  b'2 := r''.c.
  %struct r' := r''.
  c' := s''.c'.
  d' := [x: b''] (a'' -> s''.d' x).
  test := [x] s''.test.
}.

%% testing includes and subordination
%sig R' = {
  %include R.
  a' : type.
  c' : R..a.
  %% no subordination between R.a and R'.a'
}.

a : type.

%sig R'' = {
  %include R'.
  f : R..a -> R'..a'.   %% creates subordination
  c : a.                %% reference to a on toplevel
  a : type.             %% toplevel name shadowed
}.

%sig X = {
  k : type.
  l : k.
}.

%sig X' = {
  %include X.
  k' : type.
}.

%view r : R -> X = {
  a := k.
  c := l.
}.

%view r' : R' -> X' = {
  %include r.  %%i.e., R..a := X..k. R..c := X..l
  a' := k'.
  c' := X..l.
}.

%sig Y = {
  a : type.
  %struct r : R = {a := a.}.       %% R..a mapped to Y..a
  %struct r' : R' = {%include r.}. %% r'(R'..c : R..a) = r(R'..c : R..a) = r'.c : r(R..a) = r'.c : a
}.

%% multiple includes
%sig S0  = {a : type. c: a.}.
%sig S1  = {%include S0. c: S0..a.}.
%sig S2  = {%include S0. c: S0..a.}.
%sig S12 = {%include S1. %include S2. c: S0..a.}.  %% S12 includes S0 twice
%sig SX  = {a : type. c : a.}.
%view V0  : S0  -> SX = {a := a. c := c.}.
%sig SY  = {%struct k: SX. %struct k' = V0 k.}.
%view V1  : S1  -> SY = {%include V0 k. c := k.c.}.
%view V2  : S2  -> SY = {%include k'. c := k'.c.}.
%% V12 includes two views from S0 to SY: V0 SY..k and SY..k'
%% they must be equal, which is seen after definition expansion
%view V12 : S12 -> SY = {%include V1. %include V2. c := k.c.}.

%% testing opens
%sig Z = {
  %include Y %open.
  %include R %open a c %as c'.
  d = c' : a.
  %struct s : S %open a' b'.
  e = b' : a'.
  k : r.a. %% failed lookup, retried in Y.
}.

%% testing subsignatures
%sig L0 = {
  c : a.          %% a refers to toplevel a
  a : type.
  %sig L1 = {
    c : a.        %% a refers to L0..a
    a : type.
    d1 : a.       %% a refers to L1..a
    d0 : L0..a.   %% a refers to L0..a
  }.
}.

%% testing reads
%read "test3.elf".
%read "test2.elf".

%sig R3 = {
  %include R.
  %include R2.
  %struct r : R2.
  b : R..a.
  c : R2..a.
  d : r.a.
  e : r.r.a.
}.

%% testing implicit morphisms
%sig A = {}.
%sig B = {
  %struct %implicit x : X.
}.
%view %implicit c : A -> X = {}.
%sig C = {
  %struct a : A.
}.
%sig D = {
  %struct b : B.
  %struct c : C = {%struct a := b.}. %% b is coerced to c B..x b.
}.