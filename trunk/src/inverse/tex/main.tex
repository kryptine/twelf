\documentclass[11pt,twoside]{article}
\usepackage{noweb,fullpage,clrscode,proof,hyperref,amsmath,amssymb}
\usepackage{clf}

\title{Towards a Focusing Inverse-Method Theorem Prover for Canonical LF}
\author{Sean McLaughlin}

\begin{document} 
\maketitle

\arraycolsep=12pt

%-------------------------------------------------------------------------------
% Abstract                                                                      
%-------------------------------------------------------------------------------

\begin{abstract} 
This is an experiment at implementing \emph{Canonical LF}.  We intend
to present muliple forms of representation.  We will begin with a
simple name-carrying implementation of Canonical LF.  We will continue
with spine forms and explicit substitutions, and finally add
meta-variables.  Through this process, we hope to experiment with the
various representations to find a good trade-off between efficiency
and elegance.
\end{abstract} 

%-------------------------------------------------------------------------------
% Canonical LF                                                                  
%-------------------------------------------------------------------------------

\section{Canonical LF}
We begin by describing Canonical LF, the language at the
heart of our work.  While the various representations will
differ rather wildly from that presented here, this language
should always be kept in mind.

\subsection{Terms}\label{CLF:types}  
  We follow Harper and Licata \cite{HarperLicataCLF} for the
abstract syntax of Canonical LF. 

$$
\begin{array}{llll}
\textbf{Kinds} & K & ::= & \Type \Spb \PiTyp{x}{A}{K} \\
\textbf{Canonical Type Families} & A & ::= & P \Spb \PiTyp{x}{A_2}{A} \\
\textbf{Atomic Type Families} & P & ::= & a \Spb \Appl{P}{M} \\
\textbf{Canonical Terms} & M & ::= & R \Spb \Lam{x}{M} \\
\textbf{Atomic Terms} & R & ::= &  x \Spb c \Spb \Appl{R}{M}\\
\textbf{Signatures} & \Sigma & ::= & \cdot \Spb \Sigma,\Of{c}{A} 
\Spb \Sigma,\Of{a}{K}\\
\textbf{Contexts} & \Gamma & ::= & \cdot \Spb \Gamma,\Of{x}{A}\\
% \textbf{Simple Types} & \alpha & ::= & a \Spb \Arr{\alpha_1}{\alpha_2} \\
\end{array}
$$

%-------------------------------------------------------------------------------
% Spine Form LF                                                                 
%-------------------------------------------------------------------------------

\section{Spine-Form Canonical LF}

There are a number of difficulties with the naive name-carrying
implementation of Canonical LF.  The first is that we must
implement capture-avoiding substitution and $\alpha$-conversion.
This is a pain, and error-prone.  We can circumvent this difficulty
by using DeBruijn indices\cite{DeBruijn80}.  A more significant 
difficulty lies in the implementation of hereditary substitution. \incomplete{citation needed}
When applying a substitution, we often need to determine whether
the head of an expression is a constant or a variable in order
to know which rule to apply.  Thus, for a term of the form
$$f\ x_1\ x_2\ \ldots\ x_n = (\ldots((f\ x_1)\ x_2)\ \ldots\ x_n) $$
we need to take apart $n$ applications just to determine how
a substitution should be applied.  Later, when we implement
unification, that algorithm will need to compare the heads
of such terms for equality.  Thus, quick access to the head
of such a term is essential for a reasonably efficient implementation.
This is the motivation for the following definition of 
\emph{Spine-Form LF}.

\subsection{Name-carrying representation}

The name-carrying language of Spine-Form LF is given by the following
grammar.
$$
\begin{array}{llll}
\mathbf{Kinds} & K & ::= & \Type \Spb \PiTyp{x}{A}{K} \\
\mathbf{Types} & A & ::= & a\cdot S \Spb \PiTyp{x}{A_1}{A_2} \\
\mathbf{Terms} & M & ::= & H\cdot S \Spb \Lam{x}{M} \\
\mathbf{Heads} & H & ::= & c \Spb x\\
\mathbf{Spines} & S & ::= & \Nil \Spb M;S\\
\end{array} 
$$

%-------------------------------------------------------------------------------
% DeBruijn                                                                      
%-------------------------------------------------------------------------------

\subsection{DeBruijn representation}

As mentioned above, we want to use DeBruijn indices rather
than variable names.  This yields instead,

\renewcommand{\PiTyp}[2]{\Pi #1.#2}
\renewcommand{\Lam}[1]{\lambda #1}

$$
\begin{array}{llll}
\mathbf{Kinds} & K & ::= & \Type \Spb \PiTyp{A}{K} \\
\mathbf{Types} & A & ::= & a\cdot S \Spb \PiTyp{A_1}{A_2} \\
\mathbf{Terms} & M & ::= & H\cdot S \Spb \Lam{M} \\
\mathbf{Heads} & H & ::= & c \Spb i\\
\mathbf{Spines} & S & ::= & \Nil \Spb M;S\\
\end{array} 
$$

%-------------------------------------------------------------------------------
% Typechecking                                                                  
%-------------------------------------------------------------------------------

\subsection{Typechecking}

\newcommand{\CheckTy}[3][\Gamma]{#1\vdash #2 \Leftarrow #3}
\newcommand{\Focus}[4][\Gamma]{#1\vdash #2 : #3 > #4}
\newcommand{\Equiv}[2]{#1\equiv #2}


\bigskip 
\framebox{$\CheckTy{K}{\Kind}$}
\bigskip 

$$
\begin{array}{cc}
\infer{\CheckTy{\Type}{\Kind}}{} &
\infer{\CheckTy{\PiTyp{A}{K}}{\Kind}}{\CheckTy{A}{\Type} & \CheckTy[\Gamma,A]{K}{\Kind}}
\end{array} 
$$

\bigskip 
\framebox{$\CheckTy{A}{\Type}$}
\bigskip 

$$
\begin{array}{cc}
\infer{\CheckTy{\PiTyp{A_1}{A_2}}{\Type}}{\CheckTy{A_1}{\Type} & \CheckTy[\Gamma,A_1]{A_2}{\Type}} &
\infer{\CheckTy{a\cdot S}{\Type}}{\Sigma(a) = K & \Focus{S}{K}{\Type}}
\end{array} 
$$

\bigskip 
\framebox{$\CheckTy{M}{A}$}
\bigskip 

We assume that if $\CheckTy{M}{A}$ then $\CheckTy{A}{\Type}$.

$$
\begin{array}{cc}
\infer{\CheckTy{\Lam{M}}{\PiTyp{A_1}{A_2}}}{\CheckTy[\Gamma,A_1]{M}{A_2}} &
\infer{\CheckTy{c\cdot S}{A_2}}{\Sigma(c)=A_1 & \Focus{S}{A_1}{A_2'} & \Equiv{A_2'}{A_2}} \\\\
\multicolumn{2}{c}{\infer{\CheckTy{i\cdot S}{A_2}}{\Gamma(i)=A_1 & \Focus{S}{A_1[\Shift^i]}{A_2'} & \Equiv{A_2'}{A_2}}}
\end{array} 
$$

\bigskip 

Note that you must shift the type you extract from $\Gamma$, as the
free variables (indices) should point to the slots before $i$.  Moving
the type $A$ from the context to the consequent must adjust the pointers.

\bigskip 
\framebox{$\Focus{S}{K}{\Type}$}
\bigskip 

$$
\begin{array}{lr}
\infer{\Focus{\Nil}{\Type}{\Type}}{} & 
\infer{\Focus{(M;S)}{\PiTyp{A}{K}}{\Type}}{\CheckTy{M}{A} & \Focus{S}{K[M\cdot\IdSub]}{\Type}}
\end{array} 
$$

\bigskip 
\framebox{$\Focus{S}{A_1}{A_2}$}
\bigskip 

Again, we assume that if $\Focus{S}{A_1}{A_2}$ that $\CheckTy{A_1}{\Type}$.

$$
\begin{array}{lr}
\infer{\Focus{\Nil}{a\cdot S}{a\cdot S}}{} & 
\infer{\Focus{(M;S)}{\PiTyp{A_1}{A_2}}{A_3}}{\CheckTy{M}{A_1} & \Focus{S}{A_2[M\cdot\IdSub]}{A_3}}
\end{array} 
$$


%-------------------------------------------------------------------------------
% Substitutions                                                                 
%-------------------------------------------------------------------------------

\subsection{Substitutions}

Even though the substitution judgment (at this point) is operational,
and in principle a substitution is simply a list of terms $M$,
it is still useful to define a syntax of substitutions.  

\newcommand{\Msub}{[\sigma]}
\newcommand{\Ssub}{[1\cdot(\sigma\Comp\Shift)]}

$$
\begin{array}{llll}
\mathbf{Substitutions} & \sigma & ::= & M\cdot\sigma \Spb \Shift^n \\
\end{array} 
$$

(The notation $\Shift$ means $\Shift^1$, and $\IdSub$ means $\Shift^0$.)  

We can \emph{apply} subsitutions to terms.

\bigskip
\framebox{$K\Msub = K'$}

\begin{align*} 
\Type\Msub &= \Type \\
(\PiTyp{A}{K})\Msub &= \PiTyp{(A\Msub)}{(K\Ssub)}\\
\end{align*} 

\framebox{$A\Msub = A'$}

\begin{align*} 
(a\cdot S)\Msub &= a\cdot (S\Msub) \\
(\PiTyp{A_1}{A_2})\Msub &= \PiTyp{(A_1\Msub)}{(A_2\Ssub)} \\
\end{align*} 

\framebox{$M\Msub = M'$}

\begin{align*} 
(\Lam{M})\Msub &= \Lam{(M\Ssub)}\\
(c\cdot S)\Msub &= c\cdot S\Msub \\
(i\cdot S)\Msub &= \begin{cases}
                     j\cdot S\Msub \mbox{\ if $i\Msub = j$} \\
                     M \App S\Msub\mbox{\ if $i\Msub = M$}
                   \end{cases} 
\end{align*} 

\framebox{$S\Msub = S'$}

\begin{align*} 
\Nil\Msub &= \Nil\\
(M;S)\Msub &= M\Msub;S\Msub
\end{align*} 

\framebox{$i\Msub = M$}

\begin{align*} 
1[M\cdot\sigma] &= M\\
n+1[M\cdot\sigma] &= n[\sigma]\\
i[\Shift^n] &= i+n\\
% i[\sigma_1\Comp\sigma_2] &= (i[\sigma_1])[\sigma_2]
\end{align*} 

We still need the notion of beta reduction when a 
head gets instantiated with a lambda.  We show
only the possible cases.

\bigskip 
\framebox{$M \App S = M'$}

\begin{align*} 
(H\cdot S)\App\Nil &= H\cdot S\\
\Lam{M}\App(M';S) &= M[M'\cdot\IdSub]\App S
\end{align*} 

The rules for composing substitutions are:

\bigskip 
\framebox{$\sigma\Comp\sigma' = \sigma''$}

$$
\begin{array}{llll}
(M\cdot \sigma) & \Comp \sigma' &= &M[\sigma']\cdot (\sigma\Comp\sigma') \\
\Shift^n & \Comp \Shift^m &= &\Shift^{n+m}\\
\Shift^0 & \Comp \sigma &= &\sigma\\
\Shift^{n+1}&\Comp (M\cdot\sigma) &= &\Shift^n\Comp\sigma
\end{array} 
$$

%-------------------------------------------------------------------------------
% Equivalence                                                                   
%-------------------------------------------------------------------------------

\subsection{Equivalence} 

If we only allowed constant declarations in a signature then checking equivalence
of terms would be a simple matter of checking syntactic equality.  
With definitions of the form $c : A = M$, we must account
for the fact that a focusing phase might return a type $A$ to 
check against a type $A'$ that are not syntactically equal, but
if one expanded all the definitions and normalized the resulting
terms than they would be identical.  We thus need a judgment for the
equivalence of types $A$ and terms $M$.  (Since we are not allowing
type level definitions, we do not need to check for equivalent kinds.)

\newcommand{\StepsTo}{\rightsquigarrow}
\newcommand{\NoStep}{\not\rightsquigarrow}

We use the judgments $c\StepsTo M$  to mean
that the constant $c$ has definition $M$, and $c\NoStep$ means
$c$ does not have a definition (i.e. is a declared constant).

\bigskip 
\framebox{$\Equiv{A}{A'}$}
\bigskip 

$$
\begin{array}{lcr}\
\infer{\Equiv{A}{A'}}{\Equiv{A'}{A}} &  
\infer{\Equiv{\PiTyp{A_1}{A_2}}{\PiTyp{A_1'}{A_2'}}}{\Equiv{A_1}{A_1'} & \Equiv{A_2}{A_2'}} & 
\infer{\Equiv{a\cdot S}{a\cdot S'}}{\Equiv{S}{S'}} 
\end{array} 
$$

\bigskip 
\framebox{$\Equiv{S}{S'}$}
\bigskip 

$$
\begin{array}{lcr}
\infer{\Equiv{\Nil}{\Nil}}{} &
\infer{\Equiv{M;S}{M';S'}}{\Equiv{M}{M'} & \Equiv{S}{S'}}
\end{array} 
$$

\bigskip 
\framebox{$\Equiv{M}{M'}$}
\bigskip 

$$
\begin{array}{cccc}
\infer{\Equiv{\Lam{M}}{\Lam{M'}}}{\Equiv{M}{M'}} &
\infer{\Equiv{i\cdot S}{i\cdot S'}}{\Equiv{S}{S'}} &
\infer{\Equiv{c\cdot S}{c\cdot S'}}{\Equiv{S}{S'}} &
\infer{\Equiv{c\cdot S}{M}}{c\StepsTo M' & \Equiv{M'@S}{M}} 
\end{array} 
$$


\subsubsection{A Note on Implementing Equivalence Checking}

  For various reasons, we need equivalence checking to
be as fast as possible.  Equivalence checking is complicated
by notational definitions.  If checking $A=B$ fails, we might need
to expand definitions in one or both terms.  One could simply
expand all definitions to yield a sound algorithm, but this would
be horribly slow.  

  The solution given by Twelf, suggested by 
Pfenning and Reed, is to store two extra bits of information 
with each constant.  The first is the \emph{height} of a constant.
This merely records the definition depth of a constant.  Constants that
do not refer to other constants have height 0.  A constant $c$ that refers
to others has height $1 + \max\set{\mbox{height of constants occuring in } c}$.
Note that only constants with the same height can be equal.  
The second bit of data is the \emph{root}, it{i.e.} the head of the term that would be obtained by 
expanding all definitions.  Note that any two equal terms must have the
same root after full expansion. 

These two bits of data yield a natural algorithm for determining 
equivalence of terms.  If, when checking equality of $A=B$,
we find that two constants must be equal for $A,B$ to
be equivalent, but are not syntactically equal, 
we check to see if the roots are the same.
If not, we fail.  Otherwise, we check the heights.  If the heights
differ, we expand the constant with the greater height until 
they are equal, and check again.  Once the levels
are equal, while the constants are still distinct, we 
expand both definitions, level by level, until all constants
are expanded.  In the worst case, this will take as much time
as expanding all the definitions.  In the usual case, however,
where the constants differ\footnote{indeed, unification fails
around \%80 of the time}, the clash will be found long before
the terms are fully expanded.  

This leads to an additional rule 

\newcommand{\Root}{\mbox{root}}
$$
\begin{array}{cccc}
\infer{\Equiv{c\cdot S}{c'\cdot S'}}{\Root(c)=\Root(c') & \card{c} \geq \card{c'} & c\StepsTo M' & \Equiv{M'@S}{c'\cdot S'}} 
\end{array} 
$$

where $\card{c}$ is the height of $c$, and $\Root(c)$ is the root.

%-------------------------------------------------------------------------------
% Contexts                                                                      
%-------------------------------------------------------------------------------

\subsection{Contexts}

Contexts map (DeBruijn) variables to types.  

\newcommand{\Ctx}{\ \mathtt{ctx}}
\bigskip 
\framebox{$\Gamma\Ctx$}
\bigskip 

$$
\begin{array}{cc}
\infer{\cdot\Ctx}{} &
\infer{\Gamma,A\Ctx}{\Gamma\Ctx & \CheckTy[\cdot]{A}{\Type}}
\end{array} 
$$

%-------------------------------------------------------------------------------
% Signatures                                                                    
%-------------------------------------------------------------------------------

\subsection{Signatures}

Signatures map constants to types and kinds.

\newcommand{\Sig}{\ \mathtt{sig}}
\bigskip 
\framebox{$\Sigma\Sig$}
\bigskip 

$$
\begin{array}{ccc}
\infer{\cdot\Sig}{}&
\infer{\Sigma,c:A\Sig}{\Sigma\Sig & \CheckTy[\cdot]{A}{\Type}}&
\infer{\Sigma,a:K\Sig}{\Sigma\Sig & \CheckTy[\cdot]{K}{\Kind}}
\end{array} 
$$

%-------------------------------------------------------------------------------
% Uni-level                                                                     
%-------------------------------------------------------------------------------

\subsection{Uni-level representation}

Note that the rules for types and kinds are very similar.
Pfenning's experience with implementing Twelf is that if they
are separate much of the code has to be duplicated for
the two levels.  These concerns lead to the final 
grammar for Spine-Form LF, a single class of expressions for
terms, types, and kinds, classified by level.

$$
\begin{array}{llll}
\mathbf{Levels} & L & ::= & \Type \Spb \Kind \\
\mathbf{Expressions} & U & ::= & L \Spb \Pi(U_1,U_2) \Spb \lambda U \Spb H\cdot S \\
\mathbf{Heads} & H & ::= & c \Spb i\\
\mathbf{Spines} & S & ::= & \Nil \Spb U;S\\
\end{array} 
$$

%-------------------------------------------------------------------------------
% Eta expansion                                                                 
%-------------------------------------------------------------------------------

\subsection{$\eta$ Expansion}

In Canonical LF, all terms are fully $\eta$ expanded.  This can be seen
by considering the focusing rules

$$
\begin{array}{lr}
\infer{\Focus{\Nil}{a\cdot S}{a\cdot S}}{}\\
\\
\infer{\Focus{\Nil}{\Type}{\Type}}{} 
\end{array} 
$$

and the $\beta$-reduction rule

$$
(H\cdot S)\App\Nil = H\cdot S
$$

The restriction to atomic expressions means that well-typed terms
are $\eta$ expanded.  However, is interesting to formalize the notion
of an $\eta$ expanded, or $\eta$-long term.  The following judgments
make this explicit.

%% First, we define $\card{S}$ to be the length of the spine $S$.  
%% This is defined inductively as 

%% \begin{align*} 
%% \card{\Nil} = 0\\
%% \card{M;S} = 1 + \card{S}
%% \end{align*} 

We first define a simple erasure of the dependent types to obtain
a very simple skeleton of the type.  We use the term \emph{skeleton type}
to distinguish from the $\emph{erased types}$ of hereditary substitution.

\newcommand{\Skel}[3][\Gamma]{#1\vdash #2 \rightsquigarrow #3}
\newcommand{\SkBase}{o}
\newcommand{\tauskel}{\tau_1\to\tau_2\to\ldots\to\tau_n\to\SkBase}

\bigskip 
$$
\begin{array}{llll}
\mathbf{Skeleton\ Types} & \tau & ::= & \SkBase \Spb \tau_1\to\tau_2 \\
\end{array} 
$$
\bigskip 

In a skeleton type, $o$ stands for any base type $a\cdot S$ and $\to$ for any $\Pi$ type.
We assume that if $\Skel{A}{\tau}$ then $\CheckTy[\Gamma']{A}{\Type}$ in the corresponding
(unskeletonized) context $\Gamma'$.


\bigskip 
\framebox{$\Skel{A}{\tau}$}
\bigskip 

%% $$
%% \begin{array}{c}
%% \infer{\Skel{a\cdot S}{\SkBase}}{\Sigma(a) = \Pi A_1.\Pi A_2\ldots\Pi A_n.\Type & \card{S}=n}\\\\
%% \infer{\Skel{i\cdot S}{\SkBase}}{\Gamma(i) = \tauskel & \card{S}=n}\\\\
%% \infer{\Skel{\PiTyp{A_1}{A_2}}{\tau_1\to\tau_2}}{\Skel{A_1}{\tau_1} & \Skel[\Gamma,\tau_1]{A_2}{\tau_2}}
%% \end{array} 
%% $$

$$
\begin{array}{ccc}
\infer{\Skel{a\cdot S}{\SkBase}}{} &
\infer{\Skel{i\cdot S}{\SkBase}}{} &
\infer{\Skel{\PiTyp{A_1}{A_2}}{\tau_1\to\tau_2}}{\Skel{A_1}{\tau_1} & \Skel[\Gamma,\tau_1]{A_2}{\tau_2}}
\end{array} 
$$

\subsubsection{Checking $\eta$-long}

We now define the judgments defining $\eta$-long.  We assume that
each element of $\Sigma$ is $\eta$-long.  Similar to type-checking,
we need to pass the skeleton type for the argument of a $\lambda$.

\newcommand{\Long}[2][\Gamma]{#1\vdash #2\ \mathbf{long}}
\newcommand{\LongAt}[3][\Gamma]{#1\vdash #2\ \mathbf{long\ at\ } #3}

\bigskip 
\framebox{$\Long{K}$}
\bigskip 

$$
\begin{array}{lcr}
\infer{\Long{\Type}}{} & &
\infer{\Long{\PiTyp{A}{K}}}{\Long{A} & \Skel{A}{\tau} & \Long[\Gamma,\tau]{K}}
\end{array} 
$$


\bigskip 
\framebox{$\Long{A}$}
\bigskip 


$$
\begin{array}{c}
\infer{\Long{a\cdot S}}{\Skel{\Sigma(a)}{\tau} & \LongAt{S}{\tau}} \\\\
\infer{\Long{\PiTyp{A_1}{A_2}}}{\Long{A_1} & \Skel{A_1}{\tau_1} & \Long[\Gamma,\tau_1]{A_2}}
\end{array} 
$$

\bigskip 
\framebox{$\LongAt{S}{\tau}$}
\bigskip 

$$
\begin{array}{lcr}
\infer{\LongAt{\Nil}{\SkBase}}{} && 
\infer{\LongAt{M;S}{\tau_1\to\tau_2}}{\LongAt{M}{\tau_1} & \LongAt{S}{\tau_2}}
\end{array} 
$$

\bigskip 
\framebox{$\LongAt{M}{\tau}$}
\bigskip 

$$
\begin{array}{lr}
\infer{\LongAt{i\cdot S}{\SkBase}}{\LongAt{S}{\Gamma(i)}} & 
\infer{\LongAt{c\cdot S}{\SkBase}}{\Skel{\Sigma(c)}{\tau} & \LongAt{S}{\tau}}\\\\
\infer{\LongAt{\Lam{M}}{\tau_1\to\tau_2}}{\LongAt[\Gamma,\tau_1]{M}{\tau_2}}
\end{array} 
$$

\subsubsection{$\eta$-expansion}

Now, given a term that is $\beta$-normal, but possibly not $\eta$-long,
we can instrument the previous judgments with local adjustments to the
terms to yield an algorithm for ``$\eta$-lengthening'' a term.

\renewcommand{\Long}[3][\Gamma]{#1\vdash #2 > #3}
\renewcommand{\LongAt}[4][\Gamma]{#1\vdash #2\ \mathbf{at\ } #3 > #4}

\bigskip 
\framebox{$\Long{K}{K'}$}
\bigskip 

$$
\begin{array}{lcr}
\infer{\Long{\Type}{\Type}}{} & &
\infer{\Long{\PiTyp{A}{K}}{\PiTyp{A'}{K'}}}{\Long{A}{A'} & 
                           \Skel{A'}{\tau} & \Long[\Gamma,\tau]{K}{K'}}
\end{array} 
$$

We maintain the invariant in this and the following judgments that if 
$\Long{X}{Y}$ or $\LongAt{X}{\tau}{Y}$ then $Y$ is $\eta$-long.
Thus, in the second rule, $A'$ is $\eta$-long and will thus have
a valid skeleton.

\bigskip 
\framebox{$\Long{A}{A'}$}
\bigskip 

$$
\begin{array}{lcr}
\infer{\Long{a\cdot S}{a\cdot S'}}{\Skel{\Sigma(a)}{\tau} & \LongAt{S}{\tau}{S'}} &&
\infer{\Long{\PiTyp{A_1}{A_2}}{\PiTyp{A_1'}{A_2'}}}{\Long{A_1}{A_1'} & \Skel{A_1'}{\tau_1} & \Long[\Gamma,\tau_1]{A_2}{A_2'}}
\end{array} 
$$

\bigskip 
\framebox{$\LongAt{S}{\tau}{S'}$}
\bigskip 

$$
\begin{array}{lcr}
\infer{\LongAt{\Nil}{\SkBase}{\Nil}}{} && 
\infer{\LongAt{M;S}{\tau_1\to\tau_2}{M';S'}}{\LongAt{M}{\tau_1}{M'} & \LongAt{S}{\tau_2}{S'}}
\end{array} 
$$

\bigskip 
\framebox{$\LongAt{M}{\tau}{M'}$}
\bigskip 

\newcommand{\Concat}{\bowtie}

$$
\begin{array}{c}
\infer{\LongAt{i\cdot S}{\SkBase}{i\cdot S'}}{\LongAt{S}{\Gamma(i)}{S'}}\\\\
\infer{\LongAt{i\cdot S}{\tau_1\to\tau_2}{M}}{\LongAt{\Lam{(i+1)\cdot(S[\Shift] \Concat 1)}}{\tau_1\to\tau_2}{M}}\\\\
\infer{\LongAt{c\cdot S}{\SkBase}{c\cdot S'}}{\Skel{\Sigma(c)}{\tau} & \LongAt{S}{\tau}{S'}}\\\\
\infer{\LongAt{c\cdot S}{\tau_1\to\tau_2}{M}}{\LongAt{\Lam{c\cdot(S[\Shift] \Concat 1)}}{\tau_1\to\tau_2}{M}}\\\\
\infer{\LongAt{\Lam{M}}{\tau_1\to\tau_2}{\Lam{M'}}}{\LongAt[\Gamma,\tau_1]{M}{\tau_2}{M'}}
\end{array} 
$$


\bigskip 
\framebox{$S\Concat M$}
\bigskip 

The $\Concat$ operator simply appends a term to the end of a spine:

\begin{align*} 
\Nil\Concat M &= M;\Nil\\
(M;S)\Concat M' &= M;(S\Concat M')
\end{align*} 

%-------------------------------------------------------------------------------
% Non-checking                                                                  
%-------------------------------------------------------------------------------

\subsection{The ``doesn't typecheck'' judgment}

\newcommand{\NoCheck}[3][\Gamma]{#1\vdash #2 \nLeftarrow #3}
\newcommand{\NoFocus}[4][\Gamma]{#1\vdash #2 : #3 \ngtr #4}
\newcommand{\NoEquiv}[2]{#1 \not\equiv #2}

For terms that don't typecheck, we would like evidence to that
effect.  We thus define ``doesn't typecheck'' judgments mirroring
the typechecking and equivalence judgments.

\bigskip 
\framebox{$\NoCheck{K}{\Kind}$}
\bigskip 

$$
\begin{array}{ccc}
\infer{\NoCheck{\PiTyp{A}{K}}{\Kind}}{\NoCheck{A}{\Type}} &
\infer{\NoCheck{\PiTyp{A}{K}}{\Kind}}{\CheckTy{A}{\Type} & \NoCheck[\Gamma,A]{K}{\Kind}} &
\mbox{no rule for $\Type$}
\end{array} 
$$

\bigskip 
\framebox{$\NoCheck{A}{\Type}$}
\bigskip 

$$
\begin{array}{cc}
\infer{\NoCheck{a\cdot S}{\Type}}{a\not\in\Sigma} &
\infer{\NoCheck{a\cdot S}{\Type}}{\Sigma(a) = K & \NoFocus{S}{K}{\Type}} \\\\
\infer{\NoCheck{\PiTyp{A_1}{A_2}}{\Type}}{\NoCheck{A_1}{\Type}} &
\infer{\NoCheck{\PiTyp{A_1}{A_2}}{\Type}}{\CheckTy{A_1}{\Type} & \NoCheck[\Gamma,A_1]{A_2}{\Type}} 
\end{array} 
$$

\bigskip 
\framebox{$\NoCheck{M}{A}$}
\bigskip 

$$
\begin{array}{ccc}
\infer{\NoCheck{M}{A}}{\NoCheck{A}{\Type}} &
\infer{\NoCheck{\Lam{M}}{a\cdot S}}{} &
\infer{\NoCheck{\Lam{M}}{\PiTyp{A_1}{A_2}}}{\NoCheck[\Gamma,A_1]{M}{A_2}} \\\\
\infer{\NoCheck{i\cdot S}{A}}{\card{\Gamma} < i} & 
\infer{\NoCheck{i\cdot S}{A}}{\Gamma(i)=A' & \NoFocus{S}{A'}{A}} \\\\
\infer{\NoCheck{c\cdot S}{A}}{c \not\in\Sigma} & 
\infer{\NoCheck{c\cdot S}{A}}{\Sigma(c)=A' & \NoFocus{S}{A'}{A}}
\end{array} 
$$

\bigskip 
\framebox{$\NoFocus{S}{K}{\Type}$}
\bigskip 

$$
\begin{array}{ccc}
\infer{\NoFocus{S}{K}{\Type}} {\NoCheck{K}{\Kind}} &
\infer{\NoFocus{\Nil}{\PiTyp{A}{K}}{\Type}}{} &
\infer{\NoFocus{M;S}{\PiTyp{A}{K}}{\Type}}{\NoCheck{M}{A}}\\\\
\multicolumn{3}{c}{\infer{\NoFocus{M;S}{\PiTyp{A}{K}}{\Type}}{\CheckTy{M}{A} & \NoFocus[\Gamma,A]{S}{K[M\cdot\IdSub]}{\Type}}}
\end{array} 
$$

\bigskip 
\framebox{$\NoFocus{S}{A_1}{A_2}$}
\bigskip 

$$
\begin{array}{cc}
\infer{\NoFocus{S}{A_1}{A_2}} {\NoCheck{A_1}{\Type}} &
\infer{\NoFocus{S}{A_1}{A_2}} {\NoCheck{A_2}{\Type}} \\\\
\infer{\NoFocus{\Nil}{\PiTyp{A_1}{A_2}}{A_3}}{} &
\infer{\NoFocus{M;S}{a\cdot S}{A}}{} \\\\
\infer{\NoFocus{M;S}{\PiTyp{A_1}{A_2}}{A_3}}{\NoCheck{M}{A_1}} &
\infer{\NoFocus{M;S}{\PiTyp{A_1}{A_2}}{A_3}}
                  {\CheckTy{M}{A} & \NoFocus[\Gamma,A_1]{S}{A_2[M\cdot\IdSub]}{A_3}} \\\\
\infer{\NoFocus{M;S}{\PiTyp{A_1}{A_2}}{A_3}}
                  {\CheckTy{M}{A} & \Focus[\Gamma,A_1]{S}{A_2[M\cdot\IdSub]}{A_3'} & \NoEquiv{A_3'}{A_3}} 
\end{array} 
$$

\bigskip 
\framebox{$\NoEquiv{A}{A'}$}
\bigskip 

$$
\begin{array}{ccc}
\infer{\NoEquiv{A}{A'}}{\NoEquiv{A'}{A}} &
\infer{\NoEquiv{a\cdot S}{a\cdot S'}}{\NoEquiv{S}{S'}} &
\infer{\NoEquiv{a\cdot S}{a'\cdot S'}}{} \\\\
\infer{\NoEquiv{\PiTyp{A_1}{A_2}}{\PiTyp{A_1'}{A_2'}}}{\NoEquiv{A_1}{A_1'}} &
\infer{\NoEquiv{\PiTyp{A_1}{A_2}}{\PiTyp{A_1'}{A_2'}}}{\NoEquiv{A_2}{A_2'}} 
\end{array} 
$$

\bigskip 
\framebox{$\NoEquiv{M}{M'}$}
\bigskip 

$$
\begin{array}{ccc}
\infer{\NoEquiv{M}{M'}}{\NoEquiv{M'}{M}} &
\infer{\NoEquiv{i\cdot S}{i\cdot S'}}{\NoEquiv{S}{S'}} &
\infer{\NoEquiv{i\cdot S}{i'\cdot S'}}{} \\\\
\infer{\NoEquiv{c\cdot S}{c\cdot S'}}{\NoEquiv{S}{S'}} &
\infer{\NoEquiv{c\cdot S}{c'\cdot S'}}{c\NoStep & c'\NoStep} &
\infer{\NoEquiv{c\cdot S}{M}}{c\StepsTo M' & \NoEquiv{M' @ S}{M}} 
\end{array} 
$$

\bigskip 
\framebox{$\NoEquiv{S}{S'}$}
\bigskip 

$$
\begin{array}{ccc}
\infer{\NoEquiv{\Nil}{M;S}}{} &
\infer{\NoEquiv{M;S}{M';S'}}{\NoEquiv{M}{M'}} &
\infer{\NoEquiv{M;S}{M';S'}}{\NoEquiv{S}{S'}} 
\end{array} 
$$

%-------------------------------------------------------------------------------
% Sequent Calculus                                                              
%-------------------------------------------------------------------------------


\section{Sequent Calculus}

We now attempt to describe proof search for LF.
Given a type $A$, we seek to determine whether $A$ 
is inhabited. The backbone of our method will be sequent calculi.

\renewcommand{\PiTyp}[3]{\Pi #1 : #2.\ #3}
\renewcommand{\Lam}[2]{\lambda #1.\ #2}


\subsection{Backward sequent calculus}
For our sequent calculi, we distinguish between $\Pi$ types
that refer to their argument.  We write types 
$\PiTyp{x}{A}{B}$ where $x$ is not free in $B$ as
$A \LFArr B$.  The sequents have two regions in the antecedent:

\newcommand{\Sequent}[4][]{#2\ ;\ #3 \SeqArr_{#1} #4}

$$
\begin{array}{llll}
\mathbf{Sequents} & S & ::= & \Sequent[\Sigma]{\Delta}{\Gamma}{A} \\
\end{array} 
$$

\noindent 
where $\Sigma$ refers to the signature (and is usually omitted),
$\Gamma$ is a context, and $\Delta$ is a list of parameters.   
This stratification is the basis of the operational semantics
of Twelf, and is described in \incomplete{Where is this described?}
A sequent $\Sequent{\Delta}{\Gamma}{A}$
can be interpreted as ``from parameters $\Delta$ and hypotheses 
and derivations $\Gamma$ we can show $A$''.  

$$
\begin{array}{c}
\infer[init]{\Sequent{\Delta}{\Gamma,A}{A}}{} \\\\
\infer[\LFArr_R]{\Sequent{\Delta}{\Gamma}{A\LFArr B}}
                {\Sequent{\Delta}{\Gamma,A}{B}} \\\\
\infer[\LFArr_L]{\Sequent{\Delta}{\Gamma,A\LFArr B}{C}}
                {\Sequent{\Delta}{\Gamma,A\LFArr B}{A} & 
                 \Sequent{\Delta}{\Gamma,A\LFArr B,B}{C}}\\\\
\infer[\Pi_R]{\Sequent{\Delta}{\Gamma}{\PiTyp{x}{A}{B}}}
             {\Sequent{\Delta,x:A}{\Gamma}{B}} \\\\
\infer[\Pi_L]{\Sequent{\Delta}{\Gamma,\PiTyp{x}{A}{B}}{C}}
             {\Sequent{\Delta}{\Gamma,\PiTyp{x}{A}{B},\HSub{M}{x}{A}{B}}{C} & 
              \Gamma \vdash M : A}
\end{array} 
$$

\subsection{Proof terms for backward sequent calculus}

  We can attach proof terms in the following manner, giving
witnesses of inhabitation.

$$
\begin{array}{c}
\infer[init]{\Sequent{\Delta}{\Gamma,x:A}{x:A}}{} \\\\
\infer[\LFArr_R]{\Sequent{\Delta}{\Gamma}{\Lam{x}{M} : A\LFArr B}}
                {\Sequent{\Delta}{\Gamma,x:A}{M:B}} \\\\
\infer[\LFArr_L]{\Sequent{\Delta}{\Gamma,x:A\LFArr B}{\HSub{x\ M}{y}{B}{C}}}
                {\Sequent{\Delta}{\Gamma,x:A\LFArr B}{M:A} & 
                 \Sequent{\Delta}{\Gamma,x:A\LFArr B,y:B}{C}}\\\\
\infer[\Pi_R]{\Sequent{\Delta}{\Gamma}{\PiTyp{x}{A}{M}:\PiTyp{x}{A}{B}}}
             {\Sequent{\Delta,x:A}{\Gamma}{M:B}} \\\\
\infer[\Pi_L]{\Sequent{\Delta}{\Gamma,y : \PiTyp{x}{A}{B}}{[y\ M/z] C}}
             {\Sequent{\Delta}{\Gamma,y : \PiTyp{x}{A}{B},z : \HSub{M}{x}{A}{B}}{C} &
              \Gamma \vdash M : A}
\end{array} 
$$

\subsection{Forward sequent calculus}

The backward rules defined above lead to a backward style search
of the space of proof terms.  
 In some cases, it is preferable to
search forward from the program, rather than backwards from the
goal. 

\renewcommand{\Sequent}[4][]{#2\ ;\ #3 \longrightarrow_{#1} #4}

$$
\begin{array}{llll}
\mathbf{Sequents} & S & ::= & \Sequent[\Sigma]{\Delta}{\Gamma}{A} \\
\end{array} 
$$

 This is formalized in the following sequent, which in contrast
to the backward case, is read as ``from parameters $\Delta$,
using \emph{all} the hypotheses in $\Gamma$ we can show $A$''.
We correspondingly read the rules from top to bottom, rather
than from bottom to top.

$$
\begin{array}{c}
\infer[init]{\Sequent{\cdot}{A}{A}}{} \\\\
\infer[\LFArr_{R1}]{\Sequent{\Delta}{\Gamma}{A\LFArr B}}
                  {\Sequent{\Delta}{\Gamma,A}{B}} \\\\
\infer[\LFArr_{R2}]{\Sequent{\Delta}{\Gamma}{A\LFArr B}}
                  {\Sequent{\Delta}{\Gamma}{B}} \\\\
\infer[\LFArr_L]{\Sequent{\Delta}{\Gamma_1\cup\Gamma_2,A\LFArr B}{C}}
                {\Sequent{\Delta}{\Gamma_1}{A} & 
                 \Sequent{\Delta}{\Gamma_2,B}{C}}\\\\
\infer[\Pi_R]{\Sequent{\Delta}{\Gamma}{\PiTyp{x}{A}{B}}}
             {\Sequent{\Delta,x:A}{\Gamma}{B}} \\\\
\infer[\Pi_L]{\Sequent{\Delta}{\Gamma,\PiTyp{x}{A}{B}}{C}}
             {\Sequent{\Delta}{\Gamma,\HSub{M}{x}{A}{B}}{C} & 
              \Gamma \vdash M : A}
\end{array} 
$$

\subsection{ProoF Terms for Forward Sequent Calculus}

Proof terms in the forward direction are complicated by the
$\LFArr_L$ rule, where the hypotheses are split and joined.
We can handle this in one of two ways: either we can
track which hypotheses are used where and create proof terms
at each step, or we can maintain some kind of minimal information
that allows us to construct a backward-style/natural deduction
proof term when search is complete.  We have yet to experiment
with these options, and thus leave this section incomplete.

\subsection{The Subformula Property}

LF has a straightforward subformula property:

$$
\begin{array}{llll}
\mathbf{Positive} & E^+ & ::= & P^+ \Spb A_1^- \LFArr A_2^+ \Spb \PiTyp{x}{A^-}{B^+}\\
\mathbf{Negative} & E^+ & ::= & P^- \Spb A_1^+ \LFArr A_2^- \Spb \PiTyp{x}{A^+}{B^-}\\
\end{array} 
$$



%% \input{twelf_grammar.tex}
%% \input{using.tex}

\bibliographystyle{abbrv}

\bibliography{all}

\end{document}
