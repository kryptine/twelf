%sig N = { 
	    nat : type.
            z : nat.
            s : nat -> nat. 
}.

%sig L = {
	 elt : type.
	 list: type.
	 nil : list.
	 cons : elt -> list -> list.
         append : list -> list -> list -> type.
         appnil : append L nil L.
         appcons: append L (cons E M) (cons E N)
  		      <- append L M N.
 }.

%sig NL = {
	     %include N. 
             %struct L : L = {elt := N.nat.}.
             123 = L.cons (N.s N.z) (L.cons (N.s (N.s N.z)) (L.cons (N.s (N.s (N.s N.z))) L.nil)).
             %solve d : L.append 123 123 X.
}.

%sig P = {
  o: type.
  =>: o -> o -> o.    %infix left 10 =>.
  not : o -> o.
  n =  [p] (not (not p)).
}.

%sig IL = {
  %struct P : P.
  true : P.o -> type.
  =>I : (true A -> true B) -> true (A P.=> B).
  =>E : true (A P.=> B) -> true A -> true B.
  notI : ({p} true A -> true p) -> true (P.not A).
  notE : true (P.not A) -> true A -> true C.
  notnotI : true A -> true (P.n A) = [D] (notI [p:P.o] [u: true (P.not A)] (notE u D)).
}.

%sig CL = {
	 %struct P : P.
       	 %struct IL : IL = {%struct P := P.}.
         exm : IL.true (P.not (P.not A) P.=> A). 
}.

%sig DN  = {
  %struct IL : IL.
  %struct CL : CL.
  
  n = IL.P.n.

  kolm : CL.P.o -> IL.P.o -> type.
  k=> : kolm A A' -> kolm B B' -> kolm (A CL.P.=> B) (n (A' IL.P.=> B')). 
  knot : kolm A A' -> kolm (CL.P.not A) (n A').

  % Translation
  elim : CL.IL.true A -> kolm A A' -> IL.true A' -> type.

}.

%view KOLM : CL -> IL = {
   P.o := P.o.
   P.=> := [x][y] P.n (x P.=> y).
   P.not := [x] P.n (P.not x).
   IL.true := true.
   IL.=>I := [A][B][D] notnotI (=>I D).  %% implicit arguments don't work here yet
   IL.=>E := [A][B][D][E] (notI _).
   IL.notI := 
   IL.notE :=
   exm :=

}.
