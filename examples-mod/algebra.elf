% Algebraic hierarchy

%sig Magma = {
  %include FOL %open i.
  * : FOL.i -> FOL.i -> FOL.i.    %infix none 10 *.
}.

%sig MagmaCommut = {
  %include FOL %open ded forall ==.
  %struct mag : Magma %open *. 
  commut : ded forall [x] forall [y] (x * y == y * x).
}.

%sig Semigroup = {
  %include FOL %open ded forall ==.
  %struct mag : Magma %open *.
  assoc : ded forall [x] forall [y] forall [z] ((x * y) * z == x * (y * z)).
}.

%sig SemigroupCommut = {
  %include FOL.
  %struct sg : Semigroup.
  %struct mc : MagmaCommut = {%struct mag := sg.mag.}.
}.

%sig MagmaDistrib = {
  %include FOL %open ded forall ==.
  %struct mag1 : Magma.
  %struct mag2 : Magma.
  + = [x] [y] x mag1.* y.
  * = [x] [y] x mag2.* y.
  %infix none 5 +.
  %infix none 10 *.    
  dist : ded forall [x] (forall [y] (forall [z] ((x + y) * z == x * z + y * z))).
}.

%sig MagmaIdempotent = {
  %include FOL %open ded forall ==.
  %struct mag : Magma %open *. 
  idem : ded forall [x] (x * x == x). 
}.

%sig MagmaIdentity = {
  %include FOL %open ded forall ==.
  %struct mag : Magma %open *. 
  e : FOL.i.
  idenRight : ded forall [x] (x * e == x).
  idenLeft : ded forall [x] (e * x == x).
}.

%sig Monoid = {
  %include FOL %open ded forall ==.
  %struct sg : Semigroup.
  %struct mid : MagmaIdentity = {%struct mag := sg.mag.}  %open * e.
  e = mid.e.
}.

%sig MonoidCommut = {
  %include FOL %open ded forall ==.
  %struct mon : Monoid.
  %struct mc : MagmaCommut = {%struct mag := mon.sg.mag.}.
}.

%sig MagmaInverse = {
  %include FOL %open ded forall ==.
  %struct mid : MagmaIdentity  %open * e.
  inv : FOL.i -> FOL.i.
  invRight : ded forall [x] (x * (inv x) == e).
  invLeft : ded forall [x] ((inv x) * x == e). 
}. 

%sig Group = {
  %include FOL %open ded forall ==.
  %struct mon : Monoid.
  %struct minv : MagmaInverse = {%struct mid := mon.mid.}.
  inv = minv.inv.
}.

%sig GroupAbelian = {
  %include FOL.
  %struct g : Group.
  %struct mc : MagmaCommut = {%struct mag := g.mon.sg.mag.}.
  + = [x][y] x g.mon.sg.mag.* y.    %infix none 5 +.  
  0 = g.mon.mid.e.
  - = g.inv.  
}.

%sig Ring = {
  %include FOL.
  %struct ga : GroupAbelian %open + 0 -.
  %struct sg : Semigroup %open *.
  %struct md : MagmaDistrib = {%struct mag1 := ga.g.mon.sg.mag. %struct mag2 := sg.mag.}.
}.

%sig RingCommut = {
  %include FOL.
  %struct r : Ring %open + 0 - *.
  %struct mc : MagmaCommut = {%struct mag := r.sg.mag.}.
}.

%sig RingUnit = {
  %include FOL.
  %struct r : Ring %open + 0 - *.
  %struct mon : Monoid = {%struct sg := r.sg.}.
  1 = mon.e.
}.

%sig RingUnitCommut = {
  %include FOL.
  %struct ru : RingUnit %open + 0 - * 1.
  %struct mc : MagmaCommut = {%struct mag := ru.mon.sg.mag.}.
}.

%sig IntegralDomain = {
  %include FOL %open ded forall != and =>.
  %struct ru : RingUnit %open + 0 - * 1.
  noZeroDiv : ded forall [x] forall [y] (x != 0  and  y != 0  => x * y != 0).
}.  

%sig RingDivision = {
  %include FOL %open ded i forall != == =>.
  %struct ru : RingUnit %open + 0 - * 1.
  inv : i -> i.
  invLeft : ded forall [x] (x != 0  =>  x * (inv x) == 1). 
  invRight : ded forall [x] (x != 0  => (inv x) * x == 1).
}.

%sig Field = {
  %include FOL.
  %struct rd : RingDivision.
  %struct mc : MagmaCommut = {%struct mag := rd.ru.mon.sg.mag.}.
}.