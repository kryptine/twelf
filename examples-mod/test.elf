%% testing basic syntax
%sig R = {
  a : type.
  c : a.
}.

%% testing basic semantics, note why "test" is well-typed
%sig S = {
  a' : type.
  b' : a'.
  b'2: a'.
  %struct r' : R = {a := a'.}.
  c' : r'.a.
  d' : a' -> type.
  test : d' c'.
}.

%% testing instantiations of structures, try removing the instantantion of a'
%sig T = {
  a'' : type.
  b'' = a'' -> a''.
  %struct r'' : R = {a := a'' -> a''.}.
  %struct s'': S = {a' := b''. %struct r' := r''.}.
}.

%% testing a deep instantiation r''.c := f''', and a structure definition s''' = T..s'' t'''.
%% also try removing the instantiation of a''
%% note that the order of instantiations in a structure is not relevant
%sig U = {
  a''' : type.
  f''' : a''' -> a'''.
  %struct t''' : T = {r''.c := f'''. a'' := a'''.}.
  %struct s''' = T..s'' t'''.
}.

%% testing views
%view V : R -> R = {
  a := a -> a.
  c := [x] c.
}.

%% testing views with structure instantiations; not so easy to type-check by hand anymore
%% note that type reconstruction works
%view W : S -> T = {
  a' := a'' -> a''.
  b' := [x] x.
  b'2 := r''.c.
  %struct r' := r''.
  c' := s''.c'.
  d' := [x: b''] (a'' -> s''.d' x).
  test := [x] s''.test.
}.

%% testing includes and subordination
%sig R' = {
  %include R.
  a' : type.
  c' : R..a.
  %% no subordination between R.a and R'.a'
}.

a : type.

%sig R'' = {
  %include R'.
  f : R..a -> R'..a'.   %% creates subordination
  c : a.                %% reference to a on toplevel
  a : type.             %% toplevel name shadowed
}.

%% include in a view

%sig X = {
  k : type.
  l : k.
}.

%sig X' = {
  %include X.
  k' : type.
}.

%view r : R -> X = {
  a := k.
  c := l.
}.

%view r' : R' -> X' = {
  %include r.  %%i.e., R..a := X..k. R..c := X..l
  a' := k'.
  c' := X..l.
}.

%% include in a structure
%sig Y = {
  a : type.
  %struct r : R = {a := a.}.       %% R..a mapped to Y..a
  %struct r' : R' = {%include r.}. %% r'(R'..c : R..a) = r(R'..c : R..a) = r'.c : r(R..a) = r'.c : a
}.

%% multiple includes: %% S12 includes S0 twice
%sig S0  = {a : type. c: a. a' = a.}.
%sig S1  = {%include S0 %open a'. c: S0..a.}.
%sig S2  = {%include S0.          c: S0..a.}.
%sig S12 = {
   %include S1.
   %include S2.
   %% c' = c.    %% reference to c would be ambiguous between S1..c and S2..c
   c : a'.       %% reference to a' is inambiguously S0..a'
   c' = c.       %% reference to c is resolved locally
}.
%sig SX  = {a : type. c : a.}.
%view V0  : S0  -> SX = {a := a. c := c.}.
%sig SY  = {%struct k: SX. %struct k' = V0 k.}.
%view V1  : S1  -> SY = {%include V0 k. c := k.c.}.
%view V2  : S2  -> SY = {%include k'. c := k'.c.}.
%% V12 includes two views from S0 to SY: V0 SY..k and SY..k'
%% they must be equal, which is seen after definition expansion
%view V12 : S12 -> SY = {%include V1. %include V2. c := k.c.}.

%% testing opens
%sig Z = {
  %include Y.
  %include R %open a c %as c'.
  d = c' : a.
  %struct s : S %open a' b'.
  e = b' : a'.
  k : r.a. %% failed lookup, retried in Y.
}.

%% testing nested signatures and views
%sig L0 = {
  c : a.          %% a refers to toplevel a
  a : type.
  c' : a.         %% a refers to L0..a
  %sig L1 = {
    c : a.        %% a refers to L0..a
    a : type.
    d1 : a.       %% a refers to L1..a
    d0 : L0..a.   %% a refers to L0..a
  }.
  b : type.
  %sig L2 = {
     a : b.
     %% c : L1..a.   %% fails, L1 invisible
     %include L1.
     c : L1..a.
  }.
  %view L1-2 : L1 -> L2 = {
     c  := L0.L1..c.
     a  := b.
     d1 := a.
     d0 := L1..c.
  }.
}.

%% testing implicit morphisms
%% b : type. %% makes the "upward view" c below fail 
%sig A = {}.
%sig B = {
  %struct %implicit x : X.
}.
%view %implicit c : A -> X = {}.
%sig C = {
  %struct a : A.
}.
%sig D = {
  %struct b : B.
  %struct c : C = {%struct a := b.}. %% b is coerced to c B..x b.
}.

%% testing reads
%read "test3.elf".
%read "test2.elf".

%sig R3 = {
  %include R.
  %include R2.
  %struct r : R2.
  b : R..a.
  c : R2..a.
  d : r.a.
  e : r.r.a.
}.

%% testing logical relations
%sig LS = {
    a: type.
    c : a.
    f : a -> a.
    b : a -> a -> type.
    g : b XX (f XX). 
}.
%sig LT = {
   a1: type. c1: a1.
   a2: type. c2: a2.
   j : a1 -> a2 -> type.
   p : j c1 c2.
   q : {f1}{f2} j XX XY -> j (f1 XX) (f2 XY).
   u: type.
   *: u.
   eq: u -> u -> type.
   uniq : eq UU *.
}.
%view m1 : LS -> LT = {
   a := a1. c := c1. f := [x] x.
   b := [x][y] u. g := [XX] *.
}.
%view m2 : LS -> LT = {
   a := a2. c := c2. f := [x] c2.
   b := [x][y] (u -> u). g := [XX] ([x] x).
}.
%rel Rho : m1 -> m2 = {
   a := j.                    %% j : m1(a) -> m2(a) -> type.
   c := p.                    %% p : j m1(c) m2(c)
   f := [x1][x2][v: j x1 x2] (q ([x]x) ([x]c2) v).
   b := [x1][x2][v: j x1 x2][y1][y2][w: j y1 y2][b1][b2] {x:u} eq (b2 x) b1.
   g := [x1][x2][v: j x1 x2] [x:u] uniq.
}.

%% testing pre-functors
%sig Domain = {
   a : type.
}.
%sig Codomain = {
   b : type.
   c : b.
}.
%sig Functor = {
   %sig Interface = {
      %include Domain.
      param : a.
   }.
   %view Body : Codomain -> Interface = {
      b := a.
      c := param.
   }.
}.