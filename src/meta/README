README file for meta directory
------------------------------

funsyn        implements the functional calculus
funtypecheck  implements a type checker for this calculus
relfun        implements a converter from relational formulation
		of primitive recursive functions as LF signature
		to this functional calculus.


Regression test
---------------

relfun and funtypecheck are regression tested using the
command

	use "TEST/meta.sml";

from the  Twelf-SML top level. 




TODO list for relfun.com
------------------------

DONE -cs  1) lemmas 
DONE -cs  2) parameter cases
DONE -cs  3) mutual recursion
4) label store




TODO list of meta theorem prover
--------------------------------

Open issues: 
-cs  In recursion, when we look for the subterm of a functional
	assumptions, we apply it to EVars, and continue search.
	Currently we reject any induction hypothesis where any
	of these EVars is open.
     Improvement: univerally abstract over these EVars 
     (see error mesage : 	
	 * Ignored recursive call: Argument not instantiated during unification)



INVARIANT:
  1) Proof requires only the introduction of at most ONE context block
  2) All constant declarations in the signature do not have spurious variable
	occurrences   (* otherwise we cannot abstract in splitting
  		         by traversing only one substitution *)

Code Walk (Invariants, Mutual recursion)
DONE -cs Anchor into Twelf

DONE -cs Unify induction hypothesis result/residual lemmas to one construct.
DONE -cs Keep residual lemmas explicit

Make ctxblock adequate for formulas (left to right, instead  right to left)

Parameter Cases
  inductive cases:

    DONE -cs    Pruning in substitution. 
    
    DONE -cs    Add parameter introduction in the case that parameter and functional object
	do not live on the same level
    DONE -cs Add functionality for SOME clauses
    Assumption, all EVars for SOME are replaced by something closed 
	(* not a sensible assumption. Must be generalized *)
	
  base cases
    RECURSION: calculating twice induction hypothesis does not remove duplicates, check!!!
    
    TODO: expand' must construct G0 which is passed into abstracFinal to call abstraction.

    Implementation plan for abstract/splitting

	DONE -cs abstract : remove FVARs
	DONE -cs abstract : update collectSub
	DONE -cs abstract : threat d through collect
	DONE -cs abstract : add depth to EV
	DONE -cs abstract : add BV

	DONE -cs splitting: calculate G0
	DONE splitting: correct calls to   abstract
	


	TODO: Second parameter splitting to the right of a parameter block not yet detected.
	TODO: Collect all parameter in paramCases, not just the local ones.
   
	DONE - cs
	   BUG:  A context which contains already a parameter
	    block must be prepared the	
	      right way.   G1, l: G, G2

	      must yield two substitutions:

		. |- t : G1
	     
	      and 
		
	        G1 |- s : G2

	      otherwise abstraction doesn't work.
	
	DONE - cs   BUG Tag information and actual declaration can get out of sync.

	Experimentation report

	- Cut Elimination works except in the essentatial case: 
 	    Suspect that a induction hypothesis is missing  (I guess that "open issues" from above is repsonsible for that)

	- Church Rosser  interactive proof works. But
	  TODO Filling in the first step immediately succeeds (constraints!!!)
	  TODO splitting the first rewrite derivations yields a bad bad error
	


Splitting Residual lemmas
   Unify lemmas and assumptions tags: Assumption 
	<a2> X:eval E V
   could be reprsented as
	<l2: [[X:eval E V]]> X:eval E V
   this makes the code more uniform, especially in splitting. 
  

Index variables
Proof terms


Problems: Leftover constraints in TEST-CR/a.sml when proving m-subst