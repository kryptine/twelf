 % -*- mode: Noweb; noweb-code-mode: sml-mode -*-

Lazy substitution composition with eager substitution application.

<<exceptions>>=
  exception Check of string

<<datatypes>>=
  datatype uni = Type 
               | Kind
                   
  datatype head = Const of const
                | BVar of int

  datatype depend = No | Maybe

  datatype exp = Uni of uni
               | Pi of pi
               | Lam of lam 
               | Root of head * spine

       and spine = Nil
                 | App of exp * spine

  withtype pi = {var : string option,
                 arg : exp,
                 depend : depend,
                 body : exp}

       and lam = {var : string option,
                  body : exp}

  datatype sub = Dot of exp * sub
               | Shift of int
(*                | Comp of sub * sub *)

  type decl = {id : const,
               name : string,
               exp : exp,
               uni : uni}

  type def  = {id : const,
               name : string,
               exp : exp,
               def : exp,
               height : int,
               root : const,
               uni : uni}

  type abbrev = {id : const,
                 name : string,
                 exp : exp,
                 def : exp,
                 uni : uni}

  datatype dec = Decl of decl
               | Def of def
               | Abbrev of abbrev


<<spinelf.sig>>=
signature SPINE_LF =
sig

  <<exceptions>>

  type const 

  <<datatypes>>  

@ 
[[Sgn]] is a simple wrapper around the [[Signat]] structure.
It typechecks the declarations before inserting them
in the signature. This is to maintain the invariant
that the signature is well formed.
([[Signat]] itself ensures the keys (consts)
are distinct).

<<spinelf.sig>>=
  structure Sgn :
  sig
    type sgn
    val empty : unit -> sgn
    val insert : sgn -> dec -> sgn
    val lookup : sgn -> const -> dec (* raises Check *)
  end

  val check : Sgn.sgn -> exp -> exp -> unit (* raises Check *)
  val exp_to_string : Sgn.sgn -> exp -> string

end

<<spinelf.sml>>=
structure SpineLF (* : SPINE_LF *) =
struct 

  structure L = Lib
  structure Sig = Signat
  structure C = Context
  structure D = Debug

  <<exceptions>>

  type const = int 

  <<datatypes>>

  type sgn = dec Sig.sgn

  (* -------------------------------------------------------------------------- *)
  (*  Util                                                                      *)
  (* -------------------------------------------------------------------------- *)

  val expType = Uni Type
  val expKind = Uni Kind

  fun bvar n = Root(BVar n,Nil)
  val one = bvar 1
  val shift = Shift 1
  val id_sub = Shift 0

  fun id (Decl decl) = #id decl
    | id (Def def) = #id def
    | id (Abbrev abb) = #id abb

  fun name (Decl decl) = #name decl
    | name (Def def) = #name def
    | name (Abbrev abb) = #name abb

  fun is_def sgn c = 
      case Sig.lookup sgn c of
        Def _ => true
      | Abbrev _ => true
      | Decl _ => false        

  fun def sgn c = 
      case Sig.lookup sgn c of
        Def def => #def def
      | Abbrev abb => #def abb
      | Decl _ => raise Fail "def: not a def"

  (* -------------------------------------------------------------------------- *)
  (*  Debug                                                                     *)
  (* -------------------------------------------------------------------------- *)

  exception Fail_exp of string * exp
  exception Fail_exp2 of string * exp * exp
  exception Fail_exp_spine of string * exp * spine
  exception Fail_spine_exp of string * spine * exp
  exception Fail_hd_spine of string * head * spine
  exception Fail_sub_exp of string * sub * exp

  local   
    nonfix $ % & %%
    fun op$ x = Layout.str x
    fun op% x = Layout.mayAlign x
    fun op%% x = Layout.align x
    fun op& x = Layout.seq x
    fun paren x = &[$"(",x,$")"]
    fun bracket x = &[$"[",x,$"]"]
    fun squiggle x = &[$"{",x,$"}"]
    fun indent x = Layout.indent x
  in

    fun uni_to_layout Type = $"type"
      | uni_to_layout Kind = $"kind"

    fun const_to_string sgn c = name(Sig.lookup sgn c)

    fun spine_to_list Nil = []
      | spine_to_list (App(E,S)) = E::spine_to_list S

    fun head_to_layout sgn (Const c) = $(const_to_string sgn c)
      | head_to_layout sgn (BVar n) = $(Int.toString n)
        handle Fail _ => raise Fail "head_to_layout: var out of bounds"

    fun needs_parens_in_arg_pos (Uni _) = false 
      | needs_parens_in_arg_pos (Root(_,Nil)) = false
      | needs_parens_in_arg_pos _ = true

    fun needs_sparens_in_arg_pos Nil = false 
      | needs_sparens_in_arg_pos (App(E,Nil)) = needs_parens_in_arg_pos E
      | needs_sparens_in_arg_pos _ = true

    fun maybe_paren E l = if needs_parens_in_arg_pos E then paren l else l

    fun maybe_sparen S l = if needs_sparens_in_arg_pos S then paren l else l

    fun spine_to_layout sgn S = %%(map (exp_to_layout sgn) (spine_to_list S))
        
    and exp_to_layout sgn (Uni lev) = uni_to_layout lev
      | exp_to_layout sgn (Pi pi) = 
        &[$"PI ",%%[(&[maybe_paren (#arg pi) (exp_to_layout sgn (#arg pi)),$". "]),exp_to_layout sgn (#body pi)]]
      | exp_to_layout sgn (Lam lam) = &[$"LAM. ",exp_to_layout sgn (#body lam)]
      | exp_to_layout sgn (Root(H,Nil)) = head_to_layout sgn H
      | exp_to_layout sgn (Root(H,S)) = &[head_to_layout sgn H,$" ^ ",maybe_sparen S (spine_to_layout sgn S)]
    
    fun exp_to_string sgn exp = Layout.tostring (exp_to_layout sgn exp) 
    fun spine_to_string sgn exp = Layout.tostring (spine_to_layout sgn exp)

  end

@ 
\subsubsection*{Typechecking}

[[check' : Signat.sgn -> exp Context.ctx -> exp -> exp -> unit]]

\noindent
The basic typechecking function on the uni-level representation.
Basic invariants for 

\bigskip 
$[[check']]\ \Sigma\ \Gamma\ U\ V$
\bigskip 

\begin{enumerate} 
\item $\Sigma$ is a well formed signature: $\Gamma\Sig$
\item $\Gamma$ is a well formed context: $\Gamma\Ctx$
\item $[[check']]\ \Sigma\ \Gamma\ U\ V$ succeeds iff $\CheckTy{U}{V}$ with $\Sigma$
\end{enumerate} 

<<spinelf.sml>>=

  datatype ret = RetExp of exp | RetVar of int

  fun check_aux sgn ctx (Uni Type) (Uni Kind) = ()
    | check_aux sgn ctx (Lam {body=M,...}) (Pi {var,arg=U,body=V,...}) =
      check_exp sgn (C.push ctx (var,U)) M V
    | check_aux sgn ctx (Root(Const con,S)) V = 
      let 
        fun foc exp =
           let
             val U = focus sgn ctx S exp
           in
             if equiv_exp sgn ctx U V then ()
             else raise Fail_exp2 ("check_aux:0",U,V)
           end
      in
        case Sig.lookup sgn con of
           Decl decl => foc (#exp decl) 
         | Def def => foc (#exp def)
         | Abbrev abbrev => raise Fail "check_aux:1"
      end
    | check_aux sgn ctx (Root(BVar i,S)) V = 
      (case C.lookup ctx (i-1) (* DeBruijn indices start at 1 *) of
         SOME (_,A) =>
         let
           val U = focus sgn ctx S (apply_exp sgn ctx (Shift i) A) 
         in
           if equiv_exp sgn ctx U V then ()
           else raise Fail_exp2("check_aux: Root,BVar",U,V)
         end
       | NONE => raise Check ("focus: var out of bounds"))
    | check_aux sgn ctx (Pi {var,arg=A1,body=A2,...}) (uni as Uni _) = 
      (check_exp sgn ctx A1 expType;
       check_exp sgn (C.push ctx (var,A1)) A2 uni)
    | check_aux _ _ _ _ = raise Check "check: bad case"

  and check_exp sgn ctx U V = 
      (
       (* debug *)
       (* D.print ("Checking " ^ exp_to_string sgn ctx U ^ " against " ^ exp_to_string sgn ctx V); *)
       check_aux sgn ctx U V
      )

  and focus sgn ctx Nil (ty as Uni Type) = ty
    | focus sgn ctx Nil (hd as Root (Const _,_)) = hd
    | focus sgn ctx (App(M,S)) (Pi {arg=A1,body=A2,...}) =
      (check_exp sgn ctx M A1;
       focus sgn ctx S (apply_exp sgn ctx (Dot(M,id_sub)) A2))
    | focus _ _ S E = raise Fail_spine_exp("focus: bad case",S,E)
 
  (* Substitutions *)
  and apply_exp sgn ctx sub (uni as Uni _) = uni
    | apply_exp sgn ctx sub (Pi {var,arg=U,depend,body=V}) =
      Pi ({var = var,
           arg = apply_exp sgn ctx sub U,
           depend = depend,
           body = apply_exp sgn ctx (push_sub sub) V} : pi)
    | apply_exp sgn ctx sub (Lam {var,body=U}) =
      Lam {var=var,
           body=apply_exp sgn ctx (push_sub sub) U}
    | apply_exp sgn ctx sub (exp as Root(H,S)) =
      let
        val S' = apply_spine sgn ctx sub S
      in
        case H of
          Const _ => Root(H,S')
        | BVar i =>
          case apply_var sgn ctx sub i of
            RetVar j => Root(BVar j,S')
          | RetExp M => reduce sgn ctx M S'
      end

  and apply_spine sgn ctx sub Nil = Nil
    | apply_spine sgn ctx sub (App(M,S)) = App(apply_exp sgn ctx sub M,apply_spine sgn ctx sub S)

  and apply_var sgn ctx (Dot(M,sub)) i =
      if i = 1 then RetExp M else apply_var sgn ctx sub (i-1)
    | apply_var sgn ctx (Shift n) i = RetVar (i+n)
    | apply_var sgn ctx (Comp(sub1,sub2)) i =
      case apply_var sgn ctx sub1 i of
        RetExp M => RetExp (apply_exp sgn ctx sub2 M)
      | RetVar j => apply_var sgn ctx sub2 j

  and compose sgn ctx (Dot(M,sigma)) sigma' = Dot(apply

  and push_sub s = Dot(one,compose s shift)

  (* Beta *)
  and reduce sgn ctx (exp as Root(_,_)) Nil = exp
    | reduce sgn ctx (Lam {body=M,...}) (App(M',S)) =
      reduce sgn ctx (apply_exp sgn ctx (Dot(M',id_sub)) M) S
    | reduce sgn ctx E S = raise Fail_exp_spine ("reduce: bad case: head: ",E,S)



  (* Equivalence modulo defintitions *)

(* expand all definitions, for testing purposes *) 
(* 
  and expand_defs sgn ctx (uni as Uni _) = uni
    | expand_defs sgn ctx (Pi {arg=U,body=V,var,depend}) =
      Pi {arg = expand_defs sgn ctx U,
          body = expand_defs sgn ctx V,
          var = var,
          depend = depend}
    | expand_defs sgn ctx (Lam {body = U,var}) =
      Lam {var = var,
           body = expand_defs sgn ctx U}
    | expand_defs sgn ctx (Root(var as BVar _,S)) =
      Root(var,expand_defs_spine sgn ctx S)
    | expand_defs sgn ctx (Root(con as Const c,S)) =
      if not (is_def sgn c) then Root(con,expand_defs_spine sgn ctx S)
      else expand_defs sgn ctx (reduce sgn ctx (def sgn c) S)

  and expand_defs_spine sgn ctx Nil = Nil
    | expand_defs_spine sgn ctx (App(M,S)) = App(expand_defs sgn ctx M,expand_defs_spine sgn ctx S)

  and equiv_exp sgn ctx E1 E2 = (expand_defs sgn ctx E1) = (expand_defs sgn ctx E2) 
  *)

@ 
Equivalence modulo definitions.
See section \ref{main:equiv} for the motivation behind our
expression equivalence function

<<spinelf.sml>>=

  and equiv_exp sgn ctx (Uni u1) (Uni u2) = u1 = u2
    | equiv_exp sgn ctx (Pi {arg=U1,body=V1,...}) (Pi {arg=U2,body=V2,...}) =
      equiv_exp sgn ctx U1 U2 andalso equiv_exp sgn ctx V1 V2
    | equiv_exp sgn ctx (Lam {body=U,...}) (Lam {body=U',...}) =
      equiv_exp sgn ctx U U'
    | equiv_exp sgn ctx (Root(BVar i,S1)) (Root(BVar i',S2)) =
      i = i' andalso equiv_spine sgn ctx S1 S2
    | equiv_exp sgn ctx (exp as Root(Const c,S)) (exp' as Root(Const c',S')) =
      if c = c' then equiv_spine sgn ctx S S' else
      (case (Sig.lookup sgn c,Sig.lookup sgn c') of
         (Decl decl,Def def) =>
         if #root def <> #id decl then false
         else equiv_exp sgn ctx exp (reduce sgn ctx (#def def) S')
       | (Def def,Decl decl) =>
         if #root def <> #id decl then false
         else equiv_exp sgn ctx (reduce sgn ctx (#def def) S) exp'
       | (Abbrev {def,...},_) => equiv_exp sgn ctx (reduce sgn ctx def S) exp'
       | (_,Abbrev {def,...}) => equiv_exp sgn ctx exp (reduce sgn ctx def S')
       | (Def {def=def,height=h,root=rc,...},
          Def {def=def',height=h',root=rc',...}) =>
         if rc <> rc' then false else
         if h = h' then equiv_exp sgn ctx (reduce sgn ctx def S) (reduce sgn ctx def' S')
         else if h > h' then equiv_exp sgn ctx (reduce sgn ctx def S) exp'
         else equiv_exp sgn ctx exp (reduce sgn ctx def' S')
       | (_,_) => raise Check "equiv_exp: bad case")
    | equiv_exp _ _ _ _ = false

  and equiv_spine sgn ctx Nil Nil = true
    | equiv_spine sgn ctx (App(E,S)) (App(E',S')) =
      equiv_exp sgn ctx E E' andalso equiv_spine sgn ctx S S'
    | equiv_spine _ _ _ _ = false

  fun check sgn E1 E2 = check_exp sgn C.empty E1 E2

@

Sgn is a wrapper around Signat that does type checking
before insertion to preserve the consistency of the signature

<<spinelf.sml>>=

  structure Sgn =
  struct

    type sgn = dec Sig.sgn

    val empty = Sig.empty

    fun insert sgn (dec as Decl decl) = 
        (check sgn (#exp decl) (Uni (#uni decl));
         Sig.insert sgn (#id decl,dec))
      | insert sgn (dec as Def def) = 
        (check sgn (#exp def) (Uni (#uni def));
         check sgn (#def def) (#exp def);
         Sig.insert sgn (#id def,dec))
      | insert sgn (dec as Abbrev abb) = 
        (check sgn (#exp abb) (Uni (#uni abb));
         check sgn (#def abb) (#exp abb);
         Sig.insert sgn (#id abb,dec))

    fun lookup sgn c = Sig.lookup sgn c 

  end

end

