% -*- mode: Noweb; noweb-code-mode: sml-mode -*-

\subsection{Signatures}

<<exceptions>>=
  exception Signat of string

@ 
Shall we make signatures destructive or persistant?
This seems like a question to resolve later, when
we have data for both cases.  Thus, the (SML) signature
should reflect that either is possible as an implementation.

<<signat.sig>>=
signature SIGNAT =
sig
  type (''a,'b) sgn
  <<exceptions>>
  val empty : unit -> (''a,'b) sgn
  val insert : (''a,'b) sgn -> ''a * 'b -> (''a,'b) sgn
  val lookup : (''a,'b) sgn -> ''a -> 'b (* raises Signat *)
  val size : (''a,'b) sgn -> int
end

<<signat.sml>>=
structure ListSignat : SIGNAT =
struct 

  structure L = Lib
  
  type (''a,'b) sgn = (''a * 'b) list

  <<exceptions>>
                      
  fun empty() = []

  fun insert sgn p = p::sgn

  fun lookup sgn x = 
      case L.assoc x sgn of 
        SOME y => y
      | NONE => raise Signat "out of bounds"

  fun size l = length l

end

@ 
We can implement signatures more efficiently
if we know the indexing type is int.
Though this shouldn't be forced upon the user,
we can provide implementations for when this is the case.

<<signat.sml>>=
structure GrowarraySignat : SIGNAT =
struct
  
  structure L = Lib
  structure G = GrowArray

  type (''a,'b) sgn = {arr : 'b G.growarray,
                       size : int ref}

  <<exceptions>>
                      
  val size = ref 0

  fun empty() = {arr = G.empty(),
                 size = ref 0}

  fun insert (sgn:(''a,'b) sgn) (n,v) =
      (G.update (#arr sgn) n v;
       (if n > !(#size sgn) then (#size sgn) := n else ());
       sgn)

  fun lookup (sgn:(int,'b) sgn) n = G.sub (#arr sgn) n

  fun size (sgn:(int,'b) sgn) = !(#size sgn)

end

(* 
structure HashSignat : SIGNAT =
struct

  structure L = Lib
  structure H = HashTable

  type (''a,'b) sgn = (''a ,'b) H.hash_table

  val hash_fn : string->word = HashString.hashString

  fun cmp_fn : string*string->bool = (op =)

  val empty


end
*) 

structure Signat = GrowarraySignat
